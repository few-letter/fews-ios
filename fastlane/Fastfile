# Refactored Fastfile
# frozen_string_literal: true

default_platform(:ios)

# --- Configuration ---

# App identifiers
APPS = {
  "Toffs" => "com.tamsadan.toolinder",
  "Plots" => "com.annapo.plotfolio",
  "Retros" => "com.annapo.kpt",
  "Multis" => "com.annapo.taskfolio",
  "Capts" => "com.folio.world.mulling.app.ios",
  "FewCuts" => "com.annapo.fewcuts",
}.freeze

# Tuist workspace name, located in the project root
WORKSPACE_NAME = "FewsWorkspace"
WORKSPACE_PATH = "../#{WORKSPACE_NAME}.xcworkspace".freeze

# --- Lanes ---

platform :ios do
  # This is executed before any lane
  before_all do
    setup_environment
  end

  # --- Main Public Lanes ---

  desc "TestFlightì— ì•±ì„ ë¹Œë“œí•˜ê³  ì—…ë¡œë“œí•©ë‹ˆë‹¤."
  lane :upload do
    deploy(
      is_testflight: true,
      title: "TestFlight ì—…ë¡œë“œ"
    )
  end

  desc "App Storeì— ë¦¬ë·°ë¥¼ ìœ„í•´ ì•±ì„ ë¹Œë“œí•˜ê³  ì œì¶œí•©ë‹ˆë‹¤."
  lane :submit_to_appstore do
    deploy(
      submit_for_review: true,
      title: "App Store ì œì¶œ"
    )
  end

  desc "ìŠ¤í¬ë¦°ìƒ· ìƒì„±ë¶€í„° ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œê¹Œì§€ ì „ì²´ ê³¼ì •ì„ ì‹¤í–‰í•©ë‹ˆë‹¤."
  lane :full_upload do
    UI.header("ğŸš€ ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì‹œì‘: ìŠ¤í¬ë¦°ìƒ· ìƒì„± ë° App Store ì—…ë¡œë“œ")
    
    selected_apps = select_apps(all_apps: APPS.keys)
    break if selected_apps.empty?

    screenshot_results = generate_screenshots_for_apps(apps: selected_apps)
    upload_results = upload_app_details(apps: selected_apps)

    print_full_upload_summary(screenshot_results: screenshot_results, upload_results: upload_results)
  end

  desc "ì¸ì¦ì„œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."
  lane :reset do
    ["development", "appstore"].each do |type|
      match_nuke(type: type, app_identifier: APPS.values)
      match(type: type, app_identifier: APPS.values, readonly: false, username: "mooyoung2309@gmail.com")
    end
    UI.success("âœ… ì¸ì¦ì„œ ì´ˆê¸°í™” ì™„ë£Œ! ğŸ”")
  end

  # --- Private Helper Lanes ---

  private_lane :deploy do |options|
    UI.header("ğŸš€ #{options[:title]} í”„ë¡œì„¸ìŠ¤ ì‹œì‘")
    
    selected_apps = select_apps(all_apps: APPS.keys)
    break if selected_apps.empty?

    app_versions = prompt_for_version_info(apps: selected_apps)
    break unless UI.confirm("ìœ„ ì •ë³´ë¡œ ë¹Œë“œë¥¼ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")

    results = { successful: [], failed: [], build_only_success: [] }
    selected_apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{selected_apps.length}: #{app_name} ì²˜ë¦¬ ì¤‘...")
      
      version_info = app_versions[app_name]
      unless version_info
        UI.error("âŒ #{app_name}: Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ê±´ë„ˆëœë‹ˆë‹¤.")
        results[:failed] << app_name
        next
      end

      begin
        ipa_path = build_and_archive_app(app_name: app_name, version_info: version_info)

        if options[:is_testflight]
          upload_to_testflight(ipa: ipa_path, skip_waiting_for_build_processing: true)
          UI.success("âœ… #{app_name} ë¹Œë“œ ë° TestFlight ì—…ë¡œë“œ ì™„ë£Œ")
          
          begin
            upload_metadata(app_name: app_name)
            results[:successful] << app_name
          rescue => e
            UI.error("âŒ #{app_name} ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì‹¤íŒ¨: #{e.message}")
            results[:build_only_success] << app_name
          end
        else
          submit_for_review(app_name: app_name, ipa_path: ipa_path)
          results[:successful] << app_name
        end
      rescue => e
        results[:failed] << app_name
        UI.error("âŒ #{app_name} ì²˜ë¦¬ ì‹¤íŒ¨: #{e.message}")
      end
    end

    print_deploy_summary(results: results, title: options[:title])
  end

  private_lane :generate do
    UI.message("ğŸ”§ Tuist í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤...")
    Dir.chdir("..") do # Move to project root to run tuist
      sh("tuist install", log: false, error_callback: ->(result) {
        UI.message("Tuist install ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ìˆì—ˆì§€ë§Œ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤.")
      })
      sh("tuist generate --no-open")
    end
    UI.success("âœ… Tuist í”„ë¡œì íŠ¸ ìƒì„± ì™„ë£Œ!")
  end

  # --- Helper Methods ---

  def setup_environment
    api_key_json = JSON.parse(File.read("api_key.json"))
    app_store_connect_api_key(
      key_id: api_key_json["key_id"],
      issuer_id: api_key_json["issuer_id"], 
      key_content: api_key_json["key"]
    )
    
    ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
    ENV["FASTLANE_XCODEBUILD_SETTINGS_RETRIES"] = "2"
    ENV["ENABLE_USER_SCRIPT_SANDBOXING"] = "NO"
    ENV["FASTLANE_ENABLE_BETA_DELIVER_SYNC_SCREENSHOTS"] = "true"
  end

  def select_apps(all_apps:)
    UI.message("ì•±ì„ ì„ íƒí•˜ì„¸ìš”:")
    all_apps.each_with_index { |name, i| UI.message("#{i+1}. #{name}") }
    
    choices_input = UI.input("ë²ˆí˜¸ ì„ íƒ (ì—¬ëŸ¬ê°œëŠ” ì½¤ë§ˆë¡œ êµ¬ë¶„, ì˜ˆ: 1,3,5): ")
    choices = choices_input.split(',').map(&:strip).map(&:to_i)
    
    invalid_choices = choices.reject { |c| (1..all_apps.length).include?(c) }
    unless invalid_choices.empty?
      UI.error("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤: #{invalid_choices.join(', ')}")
      return []
    end
    
    selected_apps = choices.map { |c| all_apps[c-1] }.uniq
    UI.success("ì„ íƒëœ ì•±: #{selected_apps.join(', ')}")
    selected_apps
  end

  def find_plist_path(app_name)
    path = "../Apps/#{app_name}/Resources/Info.plist"
    File.exist?(path) ? File.expand_path(path) : nil
  end

  def prompt_for_version_info(apps:)
    UI.header("ğŸ“ ë²„ì „ ì •ë³´ ì…ë ¥")
    app_versions = {}
    
    apps.each do |app_name|
      plist_path = find_plist_path(app_name)
      if plist_path
        current_version = get_info_plist_value(path: plist_path, key: "CFBundleShortVersionString")
        UI.message("#{app_name} í˜„ì¬ ë²„ì „: #{current_version}")
        
        version_input = UI.input("#{app_name}ì˜ ìƒˆ ë²„ì „ (í˜„ì¬ê°’ ìœ ì§€í•˜ë ¤ë©´ ì—”í„°): ")
        version = version_input.empty? ? current_version : version_input
        build = Time.now.strftime("%Y%m%d%H%M%S")
        
        app_versions[app_name] = { plist_path: plist_path, version: version, build: build }
      else
        UI.error("#{app_name}ì˜ Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
        app_versions[app_name] = nil
      end
    end
    
    UI.header("ğŸ“‹ ì…ë ¥ëœ ë²„ì „ ì •ë³´ í™•ì¸")
    app_versions.each do |app, info|
      info ? UI.message("#{app}: ë²„ì „ #{info[:version]}, ë¹Œë“œ #{info[:build]}") : UI.error("#{app}: ì„¤ì • ë¶ˆê°€")
    end
    
    app_versions
  end

  def build_and_archive_app(app_name:, version_info:)
    UI.message("ğŸ”¨ #{app_name} ë¹Œë“œ ë° ì•„ì¹´ì´ë¸Œ ì¤‘...")
    
    set_info_plist_value(path: version_info[:plist_path], key: "CFBundleShortVersionString", value: version_info[:version])
    set_info_plist_value(path: version_info[:plist_path], key: "CFBundleVersion", value: version_info[:build])
    
    clear_derived_data
    generate
    
    output_path = "./build"
    sh("mkdir -p #{output_path}")
    
    gym(
      workspace: WORKSPACE_PATH,
      scheme: app_name,
      configuration: "Release",
      export_method: "app-store",
      clean: false,
      destination: "generic/platform=iOS",
      skip_package_dependencies_resolution: true,
      disable_package_automatic_updates: true,
      output_directory: output_path,
      output_name: app_name,
      xcargs: "-allowProvisioningUpdates -skipMacroValidation",
      export_options: {
        method: "app-store",
        compileBitcode: false,
        uploadBitcode: false,
        uploadSymbols: true,
        manageAppVersionAndBuildNumber: false
      }
    )
    
    UI.success("âœ… #{app_name} ë¹Œë“œ ì™„ë£Œ")
    "#{output_path}/#{app_name}.ipa"
  end

  def upload_metadata(app_name:)
    UI.message("ğŸ“ #{app_name} ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì¤‘...")
    upload_to_app_store(
      app_identifier: APPS[app_name],
      skip_binary_upload: true,
      skip_screenshots: true,
      force: true,
      ignore_language_directory_validation: true,
      metadata_path: "./metadata/#{app_name}"
    )
    UI.success("âœ… #{app_name} ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì™„ë£Œ")
  end

  def submit_for_review(app_name:, ipa_path:)
    UI.message("ğŸš€ #{app_name} App Store ì œì¶œ ì¤‘...")
    upload_to_app_store(
      ipa: ipa_path,
      app_identifier: APPS[app_name],
      submit_for_review: true,
      automatic_release: true,
      force: true,
      skip_screenshots: true,
      run_precheck_before_submit: true,
      ignore_language_directory_validation: true,
      metadata_path: "./metadata/#{app_name}",
      submission_information: { 
        export_compliance_uses_encryption: false,
        add_id_info_uses_idfa: false 
      }
    )
    UI.success("âœ… #{app_name} App Store ì œì¶œ ì™„ë£Œ")
  end

  def print_deploy_summary(results:, title:)
    UI.header("ğŸ“Š #{title} ê²°ê³¼ ìš”ì•½")
    
    UI.success("ğŸ‰ ì „ì²´ ê³¼ì • ì„±ê³µ: #{results[:successful].join(', ')}") if results[:successful].any?
    UI.message("âš ï¸ ë¹Œë“œ ì„±ê³µ, ë©”íƒ€ë°ì´í„° ì‹¤íŒ¨: #{results[:build_only_success].join(', ')}") if results[:build_only_success].any?
    UI.error("âŒ ë¹Œë“œ/ì—…ë¡œë“œ ì‹¤íŒ¨: #{results[:failed].join(', ')}") if results[:failed].any?
    
    total = results[:successful].length + results[:build_only_success].length + results[:failed].length
    total_success = results[:successful].length + results[:build_only_success].length
    
    if results[:failed].empty?
      UI.success("ëª¨ë“  ì•± ì²˜ë¦¬ ì™„ë£Œ! ğŸš€")
    else
      UI.message("ë¹Œë“œ ì™„ë£Œ: #{total_success}/#{total} ì„±ê³µ")
    end
  end

  # --- `full_upload` Helper Methods ---

  def generate_screenshots_for_apps(apps:)
    UI.header("ğŸ¯ 1ë‹¨ê³„: ìŠ¤í¬ë¦°ìƒ· ìƒì„±")
    results = { successful: [], failed: [] }
    
    apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{apps.length}: #{app_name} ìŠ¤í¬ë¦°ìƒ· ìƒì„± ì¤‘...")
      begin
        # Currently only "Plots" is supported, as in the original script
        if app_name.downcase != "plots"
          UI.message("âš ï¸  í˜„ì¬ #{app_name}ì€(ëŠ”) ìŠ¤í¬ë¦°ìƒ· ìƒì„±ì„ ì§€ì›í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. ê±´ë„ˆëœë‹ˆë‹¤.")
          next
        end

        run_screenshot_generator(app_name)
        results[:successful] << app_name
        UI.success("âœ… #{app_name} ìŠ¤í¬ë¦°ìƒ· ìƒì„± ë° ë³µì‚¬ ì™„ë£Œ!")
      rescue => e
        results[:failed] << { app: app_name, reason: e.message }
        UI.error("âŒ #{app_name} ìŠ¤í¬ë¦°ìƒ· ìƒì„± ì‹¤íŒ¨: #{e.message}")
      end
    end
    results
  end

  def run_screenshot_generator(app_name)
    xmakes_dir = "../xmakes"
    raise "xmakes í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{xmakes_dir}" unless Dir.exist?(xmakes_dir)

    venv_python_relative_to_appstore = "../venv/bin/python"
    xmakes_appstore_dir = File.join(xmakes_dir, "appstore")
    
    unless File.exist?(File.join(xmakes_appstore_dir, venv_python_relative_to_appstore))
      raise "Python ê°€ìƒí™˜ê²½ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. `cd ../xmakes && python3 setup_venv.py`ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”."
    end

    Dir.chdir(xmakes_appstore_dir) do
      sh("rm -rf output") if Dir.exist?("output")
      sh("#{venv_python_relative_to_appstore} run_appstore_preview.py")
      copy_screenshots(app_name: app_name)
    end
  end

  def copy_screenshots(app_name:)
    UI.message("ğŸ“ ìŠ¤í¬ë¦°ìƒ· ë³µì‚¬ ì¤‘...")
    source_dir = "output/plots" # Hardcoded "plots" as in original
    raise "ìƒì„±ëœ ìŠ¤í¬ë¦°ìƒ· í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{source_dir}" unless Dir.exist?(source_dir)

    # Get the absolute path to the project root
    project_root = File.expand_path("..")
    UI.message("DEBUG: project_root: #{project_root}")
    
    target_app_dir = File.join(project_root, "screenshots", app_name)
    UI.message("DEBUG: target_app_dir: #{target_app_dir}")
    sh("rm -rf '#{target_app_dir}'") if Dir.exist?(target_app_dir)
    sh("mkdir -p '#{target_app_dir}'")

    # Get all locales from metadata directory to ensure all screenshot directories are created
    metadata_locales = Dir.glob(File.join(project_root, "metadata", app_name, "*")).select { |f| File.directory?(f) }.map { |f| File.basename(f) }

    # Get all locales from generated screenshots
    generated_locales = Dir.glob("#{source_dir}/*/*").select { |f| File.directory?(f) }.map { |f| File.basename(f) }

    # Create directories for all locales (metadata + generated screenshots)
    all_locales = (metadata_locales + generated_locales).uniq
    all_locales.each do |locale|
      target_lang_dir = File.join(target_app_dir, locale)
      UI.message("DEBUG: target_lang_dir for #{locale}: #{target_lang_dir}")
      sh("mkdir -p '#{target_lang_dir}'")
      UI.message("ğŸ“ #{locale} ìŠ¤í¬ë¦°ìƒ· ë””ë ‰í† ë¦¬ ìƒì„±.")
    end

    # Copy generated screenshots into their respective language folders
    Dir.glob("#{source_dir}/*/*").each do |lang_dir|
      next unless File.directory?(lang_dir)
      lang_code = File.basename(lang_dir)
      target_lang_dir = File.join(target_app_dir, lang_code)
      
      # Check if there are any PNG files to copy
      png_files = Dir.glob("#{lang_dir}/*.png")
      if png_files.empty?
        UI.message("âš ï¸  #{lang_code}: ë³µì‚¬í•  PNG ìŠ¤í¬ë¦°ìƒ·ì´ ì—†ìŠµë‹ˆë‹¤.")
        next
      end
      
      cp_command = "cp '#{lang_dir}'/*.png '#{target_lang_dir}/'"
      UI.message("DEBUG: cp_command: #{cp_command}")
      sh(cp_command)
      UI.message("ğŸ“¸ #{lang_code} ìŠ¤í¬ë¦°ìƒ· ë³µì‚¬ ì™„ë£Œ.")
    end
  end

  def upload_app_details(apps:)
    UI.header("ğŸ¯ 2ë‹¨ê³„: ë©”íƒ€ë°ì´í„° ë° ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ")
    results = { successful: [], failed: [] }

    apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{apps.length}: #{app_name} ì—…ë¡œë“œ ì¤‘...")
      begin
        plist_path = find_plist_path(app_name)
        raise "Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." unless plist_path

        version = get_info_plist_value(path: plist_path, key: "CFBundleShortVersionString")
        build = Time.now.strftime("%Y%m%d%H%M%S")
        set_info_plist_value(path: plist_path, key: "CFBundleVersion", value: build)
        UI.message("ğŸ”¢ #{app_name} ë²„ì „: #{version}, ìƒˆ ë¹Œë“œ: #{build}")

        screenshots_path = "./screenshots/#{app_name}/"
        has_screenshots = Dir.exist?(screenshots_path) && !Dir.glob("#{screenshots_path}/**/*.{jpg,png,jpeg}").empty?

        # Use sync_screenshots instead of overwrite_screenshots to avoid deletion verification issues
        upload_to_app_store(
          app_identifier: APPS[app_name],
          app_version: version,
          skip_binary_upload: true,
          force: true,
          metadata_path: "./metadata/#{app_name}",
          screenshots_path: "./screenshots/#{app_name}/",
          skip_screenshots: false,
          sync_screenshots: true,
          ignore_language_directory_validation: true,
          precheck_include_in_app_purchases: false,
          run_precheck_before_submit: false
        )
        
        results[:successful] << app_name
        UI.success("âœ… #{app_name} ì—…ë¡œë“œ ì™„ë£Œ!")
      rescue => e
        if e.message.include?("Failed verification of all screenshots deleted")
          UI.important("âš ï¸ #{app_name} ìŠ¤í¬ë¦°ìƒ· ì‚­ì œ í™•ì¸ ì‹¤íŒ¨: #{e.message}")
          UI.important("ì´ ë¬¸ì œëŠ” Fastlaneì˜ ì•Œë ¤ì§„ ë™ì‘ì´ë©°, ì—…ë¡œë“œëŠ” ê³„ì†ë©ë‹ˆë‹¤.")
          UI.important("ì‹¤ì œ ì—…ë¡œë“œëŠ” ì„±ê³µí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ App Store Connectì—ì„œ í™•ì¸í•˜ì„¸ìš”.")
          results[:successful] << app_name # Consider it successful for the purpose of the overall lane
        elsif e.message.include?("screenshot") && e.message.include?("delete")
          UI.important("âš ï¸ #{app_name} ìŠ¤í¬ë¦°ìƒ· ê´€ë ¨ ì˜¤ë¥˜: #{e.message}")
          UI.important("ì´ ë¬¸ì œëŠ” Fastlaneì˜ ì•Œë ¤ì§„ ë™ì‘ì´ë©°, ì—…ë¡œë“œëŠ” ê³„ì†ë©ë‹ˆë‹¤.")
          results[:successful] << app_name
        else
          results[:failed] << { app: app_name, reason: e.message }
          UI.error("âŒ #{app_name} ì—…ë¡œë“œ ì‹¤íŒ¨: #{e.message}")
        end
      end
    end
    results
  end

  def print_full_upload_summary(screenshot_results:, upload_results:)
    UI.header("ğŸ“Š ì „ì²´ í”„ë¡œì„¸ìŠ¤ ê²°ê³¼ ìš”ì•½")

    UI.message("
--- ìŠ¤í¬ë¦°ìƒ· ìƒì„± ê²°ê³¼ ---")
    UI.success("âœ… ì„±ê³µ: #{screenshot_results[:successful].join(', ')}") if screenshot_results[:successful].any?
    UI.error("âŒ ì‹¤íŒ¨: #{screenshot_results[:failed].map { |f| f[:app] }.join(', ')}") if screenshot_results[:failed].any?

    UI.message("
--- App Store ì—…ë¡œë“œ ê²°ê³¼ ---")
    UI.success("âœ… ì„±ê³µ: #{upload_results[:successful].join(', ')}") if upload_results[:successful].any?
    UI.error("âŒ ì‹¤íŒ¨: #{upload_results[:failed].map { |f| f[:app] }.join(', ')}") if upload_results[:failed].any?

    UI.message("
ğŸ‰ ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì™„ë£Œ!")
    UI.message("ğŸ’¡ App Store Connectì—ì„œ ë³€ê²½ì‚¬í•­ì„ í™•ì¸í•˜ì„¸ìš”: https://appstoreconnect.apple.com/")
  end
end