# Refactored Fastfile
# frozen_string_literal: true

default_platform(:ios)

# --- Configuration ---

# App identifiers
APPS = {
  "Toffs" => "com.tamsadan.toolinder",
  "Plots" => "com.annapo.plotfolio",
  "Retros" => "com.annapo.kpt",
  "Multis" => "com.annapo.taskfolio",
  "Capts" => "com.folio.world.mulling.app.ios",
  "FewCuts" => "com.annapo.fewcuts",
}.freeze

# Tuist workspace name, located in the project root
WORKSPACE_NAME = "FewsWorkspace"
WORKSPACE_PATH = "../#{WORKSPACE_NAME}.xcworkspace".freeze

# CRITICAL: Screenshots path - DO NOT MODIFY THIS PATH
# This path is used throughout the application for screenshot upload
# Changing this path will break the screenshot upload functionality
SCREENSHOTS_PATH_TEMPLATE = "./fastlane/screenshots/%s/".freeze

# CRITICAL: Metadata path - DO NOT MODIFY THIS PATH
# This path is used throughout the application for metadata upload
# Changing this path will break the metadata upload functionality
METADATA_PATH_TEMPLATE = "./fastlane/metadata/%s/".freeze

# --- Lanes ---

platform :ios do
  # This is executed before any lane
  before_all do
    setup_environment
  end

  desc "App Storeì— ì•±ì„ ë¹Œë“œí•˜ê³  ì—…ë¡œë“œí•©ë‹ˆë‹¤. (ìŠ¤í¬ë¦°ìƒ· ìƒì„± ë° ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ í¬í•¨)"
  lane :upload do
    UI.header("ğŸš€ ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì‹œì‘: ìŠ¤í¬ë¦°ìƒ· ìƒì„± ë° App Store ì—…ë¡œë“œ")
    
    selected_apps = select_apps(all_apps: APPS.keys)
    break if selected_apps.empty?

    screenshot_results = generate_screenshots_for_apps(apps: selected_apps)
    upload_results = upload_app_details(apps: selected_apps)

    print_full_upload_summary(screenshot_results: screenshot_results, upload_results: upload_results)
  end

  desc "TestFlightì— ì•±ì„ ë¹Œë“œí•˜ê³  ì—…ë¡œë“œí•©ë‹ˆë‹¤."
  lane :testflight do
    deploy(
      is_testflight: true,
      title: "TestFlight ì—…ë¡œë“œ"
    )
  end

  desc "App Storeì— ë¦¬ë·°ë¥¼ ìœ„í•´ ì•±ì„ ë¹Œë“œí•˜ê³  ì œì¶œí•©ë‹ˆë‹¤."
  lane :submit_to_appstore do
    UI.header("ğŸš€ App Store ë¹Œë“œ ë° ì œì¶œ (ìŠ¤í¬ë¦°ìƒ· ìƒì„± ë° ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ í¬í•¨)")
    
    selected_apps = select_apps(all_apps: APPS.keys)
    break if selected_apps.empty?

    app_versions = prompt_for_version_info(apps: selected_apps)
    confirmation = UI.input("ìœ„ ì •ë³´ë¡œ ë¹Œë“œ ë° ì œì¶œì„ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì—”í„° ë˜ëŠ” y): ")
    break unless confirmation.empty? || confirmation.downcase.start_with?('y')

    update_version_info(app_versions: app_versions)
    screenshot_results = generate_screenshots_for_apps(apps: selected_apps)
    upload_results = upload_app_details(apps: selected_apps)
    
    # ë¹Œë“œ ë° ì œì¶œ ë‹¨ê³„
    UI.header("ğŸ¯ 3ë‹¨ê³„: ì•± ë¹Œë“œ ë° App Store ì œì¶œ")
    build_results = { successful: [], failed: [] }
    
    selected_apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{selected_apps.length}: #{app_name} ë¹Œë“œ ë° ì œì¶œ ì¤‘...")
      
      version_info = app_versions[app_name]
      unless version_info
        UI.error("âŒ #{app_name}: Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ê±´ë„ˆëœë‹ˆë‹¤.")
        build_results[:failed] << { app: app_name, reason: "Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ" }
        next
      end

      begin
        ipa_path = build_and_archive_app(app_name: app_name, version_info: version_info)
        submit_for_review(app_name: app_name, ipa_path: ipa_path)
        build_results[:successful] << app_name
        UI.success("âœ… #{app_name} ë¹Œë“œ ë° ì œì¶œ ì™„ë£Œ")
      rescue => e
        build_results[:failed] << { app: app_name, reason: e.message }
        UI.error("âŒ #{app_name} ë¹Œë“œ/ì œì¶œ ì‹¤íŒ¨: #{e.message}")
      end
    end
    
    print_full_submit_summary(
      screenshot_results: screenshot_results, 
      upload_results: upload_results, 
      build_results: build_results
    )
  end

  desc "App Storeì— ë©”íƒ€ë°ì´í„°ì™€ ìŠ¤í¬ë¦°ìƒ·ë§Œ ì—…ë¡œë“œí•©ë‹ˆë‹¤."
  lane :submit_to_appstore_info do
    UI.header("ğŸš€ App Store ë©”íƒ€ë°ì´í„° ë° ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ")
    
    selected_apps = select_apps(all_apps: APPS.keys)
    break if selected_apps.empty?

    app_versions = prompt_for_version_info(apps: selected_apps)
    confirmation = UI.input("ìœ„ ì •ë³´ë¡œ ì—…ë¡œë“œë¥¼ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì—”í„° ë˜ëŠ” y): ")
    break unless confirmation.empty? || confirmation.downcase.start_with?('y')

    update_version_info(app_versions: app_versions)
    screenshot_results = generate_screenshots_for_apps(apps: selected_apps)
    upload_results = upload_app_details(apps: selected_apps)

    print_full_upload_summary(screenshot_results: screenshot_results, upload_results: upload_results)
  end

  desc "ì¸ì¦ì„œë¥¼ ì•ˆì „í•˜ê²Œ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."
  lane :reset do
    UI.header("ğŸ”„ ì¸ì¦ì„œ ë° í”„ë¡œíŒŒì¼ ì´ˆê¸°í™” ì‹œì‘")
    
    confirmation = UI.confirm("âš ï¸ ê²½ê³ : ì´ ì‘ì—…ì€ ëª¨ë“  ê¸°ì¡´ ì¸ì¦ì„œì™€ í”„ë¡œíŒŒì¼ì„ ì‚­ì œí•©ë‹ˆë‹¤. ê³„ì†í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
    return unless confirmation
    
    ["development", "appstore"].each do |type|
      UI.header("ğŸ—‘ï¸ #{type} ì¸ì¦ì„œ ì •ë¦¬ ì¤‘...")
      begin
        # ì•ˆì „í•œ nuke ì˜µì…˜ ì‚¬ìš©
        match_nuke(
          type: type, 
          app_identifier: APPS.values,
          skip_confirmation: false,  # í™•ì¸ ê³¼ì • ìœ ì§€
          username: "mooyoung2309@gmail.com"
        )
        UI.success("âœ… #{type} ì¸ì¦ì„œ ì •ë¦¬ ì™„ë£Œ")
      rescue => nuke_error
        UI.error("âŒ #{type} ì¸ì¦ì„œ ì •ë¦¬ ì‹¤íŒ¨: #{nuke_error.message}")
        next
      end
      
      UI.header("ğŸ”§ #{type} ì¸ì¦ì„œ ì¬ìƒì„± ì¤‘...")
      begin
        # ì•ˆì „í•œ ì¬ìƒì„± ì˜µì…˜
        match(
          type: type, 
          app_identifier: APPS.values, 
          readonly: false, 
          username: "mooyoung2309@gmail.com",
          generate_apple_certs: true,  # Apple ì¸ì¦ì„œ ìƒì„± í—ˆìš©
          skip_set_partition_list: true,
          force: false,  # ê°•ì œ ìƒì„±ì€ ì•ˆí•¨
          include_all_certificates: false,
          skip_certificate_matching: false,
          platform: "ios"
        )
        UI.success("âœ… #{type} ì¸ì¦ì„œ ì¬ìƒì„± ì™„ë£Œ")
      rescue => match_error
        UI.error("âŒ #{type} ì¸ì¦ì„œ ì¬ìƒì„± ì‹¤íŒ¨: #{match_error.message}")
      end
    end
    
    UI.success("âœ… ì¸ì¦ì„œ ì´ˆê¸°í™” ì™„ë£Œ! ğŸ”")
    UI.message("ğŸ’¡ ì´ì œ ê° ì•±ì„ ë¹Œë“œí•˜ì—¬ ìƒˆ ì¸ì¦ì„œê°€ ì •ìƒ ì‘ë™í•˜ëŠ”ì§€ í™•ì¸í•˜ì„¸ìš”.")
  end

  private_lane :deploy do |options|
    UI.header("ğŸš€ #{options[:title]} í”„ë¡œì„¸ìŠ¤ ì‹œì‘")
    
    selected_apps = select_apps(all_apps: APPS.keys)
    break if selected_apps.empty?

    app_versions = prompt_for_version_info(apps: selected_apps)
    break unless UI.confirm("ìœ„ ì •ë³´ë¡œ ë¹Œë“œë¥¼ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")

    results = { successful: [], failed: [], build_only_success: [] }
    selected_apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{selected_apps.length}: #{app_name} ì²˜ë¦¬ ì¤‘...")
      
      version_info = app_versions[app_name]
      unless version_info
        UI.error("âŒ #{app_name}: Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ê±´ë„ˆëœë‹ˆë‹¤.")
        results[:failed] << app_name
        next
      end

      begin
        ipa_path = build_and_archive_app(app_name: app_name, version_info: version_info)

        if options[:is_testflight]
          upload_to_testflight(ipa: ipa_path, skip_waiting_for_build_processing: true)
          UI.success("âœ… #{app_name} ë¹Œë“œ ë° TestFlight ì—…ë¡œë“œ ì™„ë£Œ")
          
          begin
            upload_metadata(app_name: app_name)
            results[:successful] << app_name
          rescue => e
            UI.error("âŒ #{app_name} ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì‹¤íŒ¨: #{e.message}")
            results[:build_only_success] << app_name
          end
        else
          submit_for_review(app_name: app_name, ipa_path: ipa_path)
          results[:successful] << app_name
        end
      rescue => e
        results[:failed] << app_name
        UI.error("âŒ #{app_name} ì²˜ë¦¬ ì‹¤íŒ¨: #{e.message}")
      end
    end

    print_deploy_summary(results: results, title: options[:title])
  end

  private_lane :generate do
    UI.message("ğŸ”§ Tuist í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤...")
    Dir.chdir("..") do # Move to project root to run tuist
      # í˜„ì¬ ë””ë ‰í† ë¦¬ í™•ì¸
      UI.message("ğŸ“ í˜„ì¬ ë””ë ‰í† ë¦¬: #{Dir.pwd}")
      
      # tuist clean ì‹¤í–‰ (ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰)
      begin
        sh("tuist clean")
        UI.success("âœ… Tuist clean ì™„ë£Œ")
      rescue => e
        UI.message("âš ï¸ Tuist clean ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ìˆì—ˆì§€ë§Œ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤: #{e.message}")
      end
      
      # tuist install ì‹¤í–‰ (ì„±ê³µí•´ì•¼ ê³„ì† ì§„í–‰)
      UI.message("ğŸ“¦ Tuist ì¢…ì†ì„± ì„¤ì¹˜ ì¤‘...")
      begin
        sh("tuist install")
        UI.success("âœ… Tuist install ì™„ë£Œ")
      rescue => e
        UI.error("âŒ Tuist install ì‹¤íŒ¨: #{e.message}")
        raise "Tuist installì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì¢…ì†ì„±ì„ í™•ì¸í•´ì£¼ì„¸ìš”."
      end
      
      # ì ì‹œ ëŒ€ê¸° (install ì™„ë£Œ í›„ íŒŒì¼ ì‹œìŠ¤í…œ ë™ê¸°í™”)
      sleep(2)
      
      # Package.resolved íŒŒì¼ ì¡´ì¬ í™•ì¸
      if File.exist?("Tuist/Package.resolved")
        UI.success("âœ… Package.resolved íŒŒì¼ í™•ì¸")
      else
        UI.error("âŒ Package.resolved íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤. installì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
      end
      
      # tuist generate ì‹¤í–‰ (ì¬ì‹œë„ ë¡œì§ í¬í•¨)
      UI.message("ğŸ—ï¸ Tuist í”„ë¡œì íŠ¸ ìƒì„± ì¤‘...")
      generate_success = false
      retry_count = 0
      max_retries = 1
      
      begin
        sh("tuist generate --no-open")
        UI.success("âœ… Tuist generate ì™„ë£Œ")
        generate_success = true
      rescue => e
        retry_count += 1
        UI.error("âŒ Tuist generate ì‹¤íŒ¨ (#{retry_count}/#{max_retries + 1}): #{e.message}")
        
        if retry_count <= max_retries
          UI.message("â³ 3ì´ˆ í›„ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤...")
          sleep(3)
          retry
        else
          UI.error("âŒ Tuist generate ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼")
          raise "Tuist generateê°€ #{max_retries + 1}ë²ˆ ì‹œë„ ëª¨ë‘ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: #{e.message}"
        end
      end
      
      # ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ ìƒì„± í™•ì¸
      workspace_file = "#{WORKSPACE_NAME}.xcworkspace"
      if File.exist?(workspace_file)
        UI.success("âœ… ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ ìƒì„± í™•ì¸: #{workspace_file}")
      else
        UI.error("âŒ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ì´ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤: #{workspace_file}")
        raise "ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ ìƒì„± ì‹¤íŒ¨"
      end
    end
    UI.success("âœ… Tuist í”„ë¡œì íŠ¸ ìƒì„± ì™„ë£Œ!")
  end

  def setup_environment
    api_key_json = JSON.parse(File.read("api_key.json"))
    app_store_connect_api_key(
      key_id: api_key_json["key_id"],
      issuer_id: api_key_json["issuer_id"], 
      key_content: api_key_json["key"]
    )
    
    ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
    ENV["FASTLANE_XCODEBUILD_SETTINGS_RETRIES"] = "2"
    ENV["ENABLE_USER_SCRIPT_SANDBOXING"] = "NO"
    ENV["FASTLANE_ENABLE_BETA_DELIVER_SYNC_SCREENSHOTS"] = "true"
    ENV["FASTLANE_SCREENSHOT_PROCESSING_TIMEOUT"] = "120"
    ENV["FASTLANE_SKIP_SET_PARTITION_LIST"] = "true"
  end

  def select_apps(all_apps:)
    UI.message("ì•±ì„ ì„ íƒí•˜ì„¸ìš”:")
    all_apps.each_with_index { |name, i| UI.message("#{i+1}. #{name}") }
    
    choices_input = UI.input("ë²ˆí˜¸ ì„ íƒ (ì—¬ëŸ¬ê°œëŠ” ì½¤ë§ˆë¡œ êµ¬ë¶„, ì˜ˆ: 1,3,5): ")
    choices = choices_input.split(',').map(&:strip).map(&:to_i)
    
    invalid_choices = choices.reject { |c| (1..all_apps.length).include?(c) }
    unless invalid_choices.empty?
      UI.error("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤: #{invalid_choices.join(', ')}")
      return []
    end
    
    selected_apps = choices.map { |c| all_apps[c-1] }.uniq
    UI.success("ì„ íƒëœ ì•±: #{selected_apps.join(', ')}")
    selected_apps
  end

  def find_plist_path(app_name)
    path = "../Apps/#{app_name}/Resources/Info.plist"
    File.exist?(path) ? File.expand_path(path) : nil
  end

  def prompt_for_version_info(apps:)
    UI.header("ğŸ“ ë²„ì „ ì •ë³´ ì…ë ¥")
    app_versions = {}
    
    apps.each do |app_name|
      plist_path = find_plist_path(app_name)
      if plist_path
        current_version = get_info_plist_value(path: plist_path, key: "CFBundleShortVersionString")
        UI.message("#{app_name} í˜„ì¬ ë²„ì „: #{current_version}")
        
        version_input = UI.input("#{app_name}ì˜ ìƒˆ ë²„ì „ (í˜„ì¬ê°’ ìœ ì§€í•˜ë ¤ë©´ ì—”í„°): ")
        version = version_input.empty? ? current_version : version_input
        build = Time.now.strftime("%Y%m%d%H%M%S")
        
        app_versions[app_name] = { plist_path: plist_path, version: version, build: build }
      else
        UI.error("#{app_name}ì˜ Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
        app_versions[app_name] = nil
      end
    end
    
    UI.header("ğŸ“‹ ì…ë ¥ëœ ë²„ì „ ì •ë³´ í™•ì¸")
    app_versions.each do |app, info|
      info ? UI.message("#{app}: ë²„ì „ #{info[:version]}, ë¹Œë“œ #{info[:build]}") : UI.error("#{app}: ì„¤ì • ë¶ˆê°€")
    end
    
    app_versions
  end

  def update_version_info(app_versions:)
    UI.header("ğŸ”„ ë²„ì „ ì •ë³´ ì—…ë°ì´íŠ¸ ì¤‘...")
    
    app_versions.each do |app_name, version_info|
      next unless version_info
      
      UI.message("ğŸ“ #{app_name} ë²„ì „ ì—…ë°ì´íŠ¸: #{version_info[:version]}, ë¹Œë“œ: #{version_info[:build]}")
      set_info_plist_value(path: version_info[:plist_path], key: "CFBundleShortVersionString", value: version_info[:version])
      set_info_plist_value(path: version_info[:plist_path], key: "CFBundleVersion", value: version_info[:build])
    end
    
    UI.success("âœ… ëª¨ë“  ì•±ì˜ ë²„ì „ ì •ë³´ ì—…ë°ì´íŠ¸ ì™„ë£Œ")
  end

  def build_and_archive_app(app_name:, version_info:)
    UI.message("ğŸ”¨ #{app_name} ë¹Œë“œ ë° ì•„ì¹´ì´ë¸Œ ì¤‘...")
    
    temp_keychain_name = "login"  # ê¸°ë³¸ê°’
    temp_keychain_path = "login.keychain"  # ê¸°ë³¸ê°’
    
    begin
      # ë²„ì „ ì •ë³´ ì—…ë°ì´íŠ¸
      set_info_plist_value(path: version_info[:plist_path], key: "CFBundleShortVersionString", value: version_info[:version])
      set_info_plist_value(path: version_info[:plist_path], key: "CFBundleVersion", value: version_info[:build])
      
      # íŒŒìƒ ë°ì´í„° ì •ë¦¬ ë° í”„ë¡œì íŠ¸ ìƒì„±
      clear_derived_data
      generate
      
      # ì„ì‹œ í‚¤ì²´ì¸ ìƒì„± ë° ì„¤ì •
      temp_keychain_name = "fastlane_#{app_name}_#{Time.now.to_i}"
      temp_keychain_path = "#{temp_keychain_name}.keychain"
      
      UI.message("ğŸ” ì„ì‹œ í‚¤ì²´ì¸ ìƒì„± ì¤‘: #{temp_keychain_name}")
      begin
        # ê¸°ì¡´ ì„ì‹œ í‚¤ì²´ì¸ ì‚­ì œ (ìˆë‹¤ë©´)
        sh("security delete-keychain #{temp_keychain_path} 2>/dev/null || true")
        
        # ìƒˆ ì„ì‹œ í‚¤ì²´ì¸ ìƒì„±
        sh("security create-keychain -p '' #{temp_keychain_path}")
        sh("security set-keychain-settings -t 3600 -l #{temp_keychain_path}")
        sh("security unlock-keychain -p '' #{temp_keychain_path}")
        
        # í‚¤ì²´ì¸ ê²€ìƒ‰ ëª©ë¡ì— ì¶”ê°€
        sh("security list-keychains -s #{temp_keychain_path} login.keychain")
        
        UI.success("âœ… ì„ì‹œ í‚¤ì²´ì¸ ìƒì„± ì™„ë£Œ: #{temp_keychain_name}")
      rescue => e
        UI.message("âš ï¸ ì„ì‹œ í‚¤ì²´ì¸ ìƒì„± ì¤‘ ê²½ê³  (ê¸°ì¡´ í‚¤ì²´ì¸ ì‚¬ìš©): #{e.message}")
        temp_keychain_name = "login"
        temp_keychain_path = "login.keychain"
      end
      
      # ì¸ì¦ì„œ ì„¤ì • (ì„ì‹œ í‚¤ì²´ì¸ ì‚¬ìš©)
      UI.message("ğŸ” ì¸ì¦ì„œ ì„¤ì • ì¤‘ (ì„ì‹œ í‚¤ì²´ì¸: #{temp_keychain_name})...")
      
      # ëª¨ë“  ì•±ì— ëŒ€í•´ ë™ì¼í•œ ë¡œì§ ì‚¬ìš©
      begin
        # ë¨¼ì € readonly ëª¨ë“œë¡œ ê¸°ì¡´ ì¸ì¦ì„œ ì‹œë„
        match(
          type: "appstore",
          app_identifier: APPS[app_name],
          readonly: true,
          skip_set_partition_list: true,
          keychain_name: temp_keychain_path,
          keychain_password: "",
          skip_certificate_matching: false,
          generate_apple_certs: false,  # ê¸°ì¡´ ì¸ì¦ì„œë§Œ ì‚¬ìš©
          platform: "ios"
        )
        UI.success("âœ… #{app_name} ê¸°ì¡´ ì¸ì¦ì„œë¡œ í”„ë¡œíŒŒì¼ ë‹¤ìš´ë¡œë“œ ì™„ë£Œ")
      rescue => e
        if e.message.include?("No matching provisioning profiles found") || 
           e.message.include?("cannot create a new one because you enabled `readonly`") ||
           e.message.include?("not valid") ||
           e.message.include?("expired")
          UI.important("âš ï¸ #{app_name}ì˜ provisioning profile ë¬¸ì œ: #{e.message}")
          UI.important("ìƒˆë¡œìš´ ì¸ì¦ì„œ ë° í”„ë¡œíŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤...")
          
          # ìƒˆë¡œ ìƒì„±í•  ë•ŒëŠ” ì•ˆì „í•œ ì˜µì…˜ ì‚¬ìš©
          match(
            type: "appstore",
            app_identifier: APPS[app_name],
            readonly: false,
            skip_set_partition_list: true,
            keychain_name: temp_keychain_path,
            keychain_password: "",
            username: "mooyoung2309@gmail.com",
            generate_apple_certs: true,  # Apple ì¸ì¦ì„œ ìƒì„± í—ˆìš©
            skip_provisioning_profiles: false,
            platform: "ios",
            force: false,  # ê°•ì œ ì¬ìƒì„±ì€ ì•ˆí•¨
            include_all_certificates: false,
            skip_certificate_matching: false  # ê²€ì¦ ìœ ì§€
          )
          UI.success("âœ… #{app_name}ì˜ ìƒˆ provisioning profile ìƒì„± ì™„ë£Œ")
        else
          # ë‹¤ë¥¸ ì—ëŸ¬ëŠ” ê·¸ëŒ€ë¡œ ì „íŒŒ
          raise e
        end
      end
      
      # ë¹Œë“œ ë””ë ‰í† ë¦¬ ìƒì„±
      output_path = "./build"
      sh("mkdir -p #{output_path}")
      
      # ë¹Œë“œ ì§ì „ í‚¤ì²´ì¸ ì ê¸ˆ í•´ì œ
      UI.message("ğŸ”“ ë¹Œë“œë¥¼ ìœ„í•œ í‚¤ì²´ì¸ ì ê¸ˆ í•´ì œ: #{temp_keychain_name}...")
      begin
        sh("security unlock-keychain -p '' #{temp_keychain_path}")
        sh("security set-keychain-settings -t 3600 -l #{temp_keychain_path}")
      rescue => e
        UI.message("âš ï¸ í‚¤ì²´ì¸ ì„¤ì • ì¤‘ ê²½ê³  (ë¬´ì‹œí•´ë„ ë¨): #{e.message}")
      end
      
      # ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ì˜ ì ˆëŒ€ ê²½ë¡œ í™•ì¸
      workspace_path = File.expand_path(WORKSPACE_PATH)
      UI.message("ğŸ” ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ê²½ë¡œ: #{workspace_path}")
      
      unless File.exist?(workspace_path)
        UI.error("âŒ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{workspace_path}")
        raise "ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{workspace_path}"
      end
      
      # ì•± ë¹Œë“œ ë° ì•„ì¹´ì´ë¸Œ
      gym(
        workspace: workspace_path,
        scheme: app_name,
        configuration: "Release",
        export_method: "app-store",
        clean: false,
        destination: "generic/platform=iOS",
        skip_package_dependencies_resolution: true,
        disable_package_automatic_updates: true,
        output_directory: output_path,
        output_name: app_name,
        xcargs: "-allowProvisioningUpdates -skipMacroValidation -CODE_SIGN_STYLE=Manual",
        export_options: {
          method: "app-store",
          compileBitcode: false,
          uploadBitcode: false,
          uploadSymbols: true,
          manageAppVersionAndBuildNumber: false,
          signingStyle: "manual",
          provisioningProfiles: {
            APPS[app_name] => "match AppStore #{APPS[app_name]}"
          }
        }
      )
      
      UI.success("âœ… #{app_name} ë¹Œë“œ ì™„ë£Œ")
      
      # IPA íŒŒì¼ ê²½ë¡œ ë°˜í™˜
      return "#{output_path}/#{app_name}.ipa"
      
    rescue => e
      # ì—ëŸ¬ ë°œìƒ ì‹œì—ë„ ì„ì‹œ í‚¤ì²´ì¸ ì •ë¦¬
      UI.error("âŒ ë¹Œë“œ ì¤‘ ì—ëŸ¬ ë°œìƒ: #{e.message}")
      unless temp_keychain_name == "login"
        UI.message("ğŸ§¹ ì—ëŸ¬ ë°œìƒìœ¼ë¡œ ì¸í•œ ì„ì‹œ í‚¤ì²´ì¸ ì •ë¦¬: #{temp_keychain_name}")
        begin
          sh("security delete-keychain #{temp_keychain_path} 2>/dev/null || true")
          sh("security list-keychains -s login.keychain")
        rescue => cleanup_error
          UI.message("âš ï¸ ì„ì‹œ í‚¤ì²´ì¸ ì •ë¦¬ ì¤‘ ê²½ê³ : #{cleanup_error.message}")
        end
      end
      raise e
      
    ensure
      # ì„±ê³µ/ì‹¤íŒ¨ì™€ ê´€ê³„ì—†ì´ í•­ìƒ ì„ì‹œ í‚¤ì²´ì¸ ì •ë¦¬
      unless temp_keychain_name == "login"
        UI.message("ğŸ§¹ ì„ì‹œ í‚¤ì²´ì¸ ì •ë¦¬ ì¤‘: #{temp_keychain_name}")
        begin
          sh("security delete-keychain #{temp_keychain_path} 2>/dev/null || true")
          sh("security list-keychains -s login.keychain")
          UI.success("âœ… ì„ì‹œ í‚¤ì²´ì¸ ì •ë¦¬ ì™„ë£Œ")
        rescue => e
          UI.message("âš ï¸ ì„ì‹œ í‚¤ì²´ì¸ ì •ë¦¬ ì¤‘ ê²½ê³  (ë¬´ì‹œí•´ë„ ë¨): #{e.message}")
        end
      end
    end
  end

  def upload_metadata(app_name:)
    UI.message("ğŸ“ #{app_name} ë©”íƒ€ë°ì´í„° ë° ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ ì¤‘...")
    upload_to_app_store(
      app_identifier: APPS[app_name],
      skip_binary_upload: true,
      skip_screenshots: false,
      force: true,
      ignore_language_directory_validation: true,
      metadata_path: METADATA_PATH_TEMPLATE % app_name,
      screenshots_path: SCREENSHOTS_PATH_TEMPLATE % app_name,
      sync_screenshots: true
    )
    UI.success("âœ… #{app_name} ë©”íƒ€ë°ì´í„° ë° ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ ì™„ë£Œ")
  end

  def submit_for_review(app_name:, ipa_path:)
    UI.message("ğŸš€ #{app_name} App Store ì œì¶œ ì¤‘...")
    upload_to_app_store(
      ipa: ipa_path,
      app_identifier: APPS[app_name],
      submit_for_review: true,
      automatic_release: true,
      force: true,
      skip_screenshots: true,
      run_precheck_before_submit: true,
      ignore_language_directory_validation: true,
      metadata_path: METADATA_PATH_TEMPLATE % app_name,
      submission_information: { 
        export_compliance_uses_encryption: false,
        add_id_info_uses_idfa: false 
      }
    )
    UI.success("âœ… #{app_name} App Store ì œì¶œ ì™„ë£Œ")
  end

  def print_deploy_summary(results:, title:)
    UI.header("ğŸ“Š #{title} ê²°ê³¼ ìš”ì•½")
    
    UI.success("ğŸ‰ ì „ì²´ ê³¼ì • ì„±ê³µ: #{results[:successful].join(', ')}") if results[:successful].any?
    UI.message("âš ï¸ ë¹Œë“œ ì„±ê³µ, ë©”íƒ€ë°ì´í„° ì‹¤íŒ¨: #{results[:build_only_success].join(', ')}") if results[:build_only_success].any?
    UI.error("âŒ ë¹Œë“œ/ì—…ë¡œë“œ ì‹¤íŒ¨: #{results[:failed].join(', ')}") if results[:failed].any?
    
    total = results[:successful].length + results[:build_only_success].length + results[:failed].length
    total_success = results[:successful].length + results[:build_only_success].length
    
    if results[:failed].empty?
      UI.success("ëª¨ë“  ì•± ì²˜ë¦¬ ì™„ë£Œ! ğŸš€")
    else
      UI.message("ë¹Œë“œ ì™„ë£Œ: #{total_success}/#{total} ì„±ê³µ")
    end
  end

  def generate_screenshots_for_apps(apps:)
    UI.header("ğŸ¯ 1ë‹¨ê³„: ìŠ¤í¬ë¦°ìƒ· ìƒì„±")
    results = { successful: [], failed: [] }
    
    apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{apps.length}: #{app_name} ìŠ¤í¬ë¦°ìƒ· ìƒì„± ì¤‘...")
      begin

        run_screenshot_generator(app_name)
        results[:successful] << app_name
        UI.success("âœ… #{app_name} ìŠ¤í¬ë¦°ìƒ· ìƒì„± ë° ë³µì‚¬ ì™„ë£Œ!")
      rescue => e
        results[:failed] << { app: app_name, reason: e.message }
        UI.error("âŒ #{app_name} ìŠ¤í¬ë¦°ìƒ· ìƒì„± ì‹¤íŒ¨: #{e.message}")
      end
    end
    results
  end

  def run_screenshot_generator(app_name)
    xmakes_dir = "../xmakes"
    raise "xmakes í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{xmakes_dir}" unless Dir.exist?(xmakes_dir)

    venv_python_relative_to_appstore = "../venv/bin/python"
    xmakes_appstore_dir = File.join(xmakes_dir, "appstore")
    
    unless File.exist?(File.join(xmakes_appstore_dir, venv_python_relative_to_appstore))
      raise "Python ê°€ìƒí™˜ê²½ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. `cd ../xmakes && python3 setup_venv.py`ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”."
    end

    Dir.chdir(xmakes_appstore_dir) do
      sh("rm -rf output") if Dir.exist?("output")
      sh("#{venv_python_relative_to_appstore} run_appstore_preview.py #{app_name}")
      copy_screenshots(app_name: app_name)
    end
  end

  def copy_screenshots(app_name:)
    UI.message("ğŸ“ ìŠ¤í¬ë¦°ìƒ· ë³µì‚¬ ì¤‘...")
    source_dir = "output/#{app_name}"
    raise "ìƒì„±ëœ ìŠ¤í¬ë¦°ìƒ· í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{source_dir}" unless Dir.exist?(source_dir)

    project_root = File.expand_path("../..")
    
    target_app_dir = File.join(project_root, "fastlane", "screenshots", app_name)
    sh("rm -rf '#{target_app_dir}'") if Dir.exist?(target_app_dir)
    sh("mkdir -p '#{target_app_dir}'")

    metadata_locales = Dir.glob(File.join(project_root, "fastlane", "metadata", app_name, "*")).select { |f| File.directory?(f) }.map { |f| File.basename(f) }

    generated_locales = Dir.glob("#{source_dir}/*/*").select { |f| File.directory?(f) }.map { |f| File.basename(f) }

    all_locales = (metadata_locales + generated_locales).uniq
    all_locales.each do |locale|
      target_lang_dir = File.join(target_app_dir, locale)
      sh("mkdir -p '#{target_lang_dir}'")
      UI.message("ğŸ“ #{locale} ìŠ¤í¬ë¦°ìƒ· ë””ë ‰í† ë¦¬ ìƒì„±.")
    end

    Dir.glob("#{source_dir}/*/*").each do |lang_dir|
      next unless File.directory?(lang_dir)
      lang_code = File.basename(lang_dir)
      target_lang_dir = File.join(target_app_dir, lang_code)
      
      png_files = Dir.glob("#{lang_dir}/*.png")
      if png_files.empty?
        UI.message("âš ï¸  #{lang_code}: ë³µì‚¬í•  PNG ìŠ¤í¬ë¦°ìƒ·ì´ ì—†ìŠµë‹ˆë‹¤.")
        next
      end
      
      sh("cp '#{lang_dir}'/*.png '#{target_lang_dir}/'")
      UI.message("ğŸ“¸ #{lang_code} ìŠ¤í¬ë¦°ìƒ· ë³µì‚¬ ì™„ë£Œ.")
    end
  end

  def upload_app_details(apps:)
    UI.header("ğŸ¯ 2ë‹¨ê³„: ë©”íƒ€ë°ì´í„° ë° ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ")
    results = { successful: [], failed: [] }

    apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{apps.length}: #{app_name} ì—…ë¡œë“œ ì¤‘...")
      begin
        plist_path = find_plist_path(app_name)
        raise "Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." unless plist_path

        version = get_info_plist_value(path: plist_path, key: "CFBundleShortVersionString")
        build = Time.now.strftime("%Y%m%d%H%M%S")
        set_info_plist_value(path: plist_path, key: "CFBundleVersion", value: build)
        UI.message("ğŸ”¢ #{app_name} ë²„ì „: #{version}, ìƒˆ ë¹Œë“œ: #{build}")

        screenshots_path = SCREENSHOTS_PATH_TEMPLATE % app_name
        has_screenshots = Dir.exist?(screenshots_path) && !Dir.glob("#{screenshots_path}/**/*.{jpg,png,jpeg}").empty?

        upload_to_app_store(
          app_identifier: APPS[app_name],
          app_version: version,
          skip_binary_upload: true,
          force: true,
          metadata_path: METADATA_PATH_TEMPLATE % app_name,
          screenshots_path: SCREENSHOTS_PATH_TEMPLATE % app_name,
          skip_screenshots: false,
          sync_screenshots: true,
          ignore_language_directory_validation: true,
          precheck_include_in_app_purchases: false,
          run_precheck_before_submit: false
        )
        
        results[:successful] << app_name
        UI.success("âœ… #{app_name} ì—…ë¡œë“œ ì™„ë£Œ!")
      rescue => e
        if e.message.include?("Failed verification of all screenshots deleted")
          UI.important("âš ï¸ #{app_name} ìŠ¤í¬ë¦°ìƒ· ì‚­ì œ í™•ì¸ ì‹¤íŒ¨: #{e.message}")
          UI.important("ì´ ë¬¸ì œëŠ” Fastlaneì˜ ì•Œë ¤ì§„ ë™ì‘ì´ë©°, ì—…ë¡œë“œëŠ” ê³„ì†ë©ë‹ˆë‹¤.")
          UI.important("ì‹¤ì œ ì—…ë¡œë“œëŠ” ì„±ê³µí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ App Store Connectì—ì„œ í™•ì¸í•˜ì„¸ìš”.")
          results[:successful] << app_name # Consider it successful for the purpose of the overall lane
        elsif e.message.include?("screenshot") && e.message.include?("delete")
          UI.important("âš ï¸ #{app_name} ìŠ¤í¬ë¦°ìƒ· ê´€ë ¨ ì˜¤ë¥˜: #{e.message}")
          UI.important("ì´ ë¬¸ì œëŠ” Fastlaneì˜ ì•Œë ¤ì§„ ë™ì‘ì´ë©°, ì—…ë¡œë“œëŠ” ê³„ì†ë©ë‹ˆë‹¤.")
          results[:successful] << app_name
        else
          results[:failed] << { app: app_name, reason: e.message }
          UI.error("âŒ #{app_name} ì—…ë¡œë“œ ì‹¤íŒ¨: #{e.message}")
        end
      end
    end
    results
  end

  def print_full_upload_summary(screenshot_results:, upload_results:)
    UI.header("ğŸ“Š ì „ì²´ í”„ë¡œì„¸ìŠ¤ ê²°ê³¼ ìš”ì•½")

    UI.message("
--- ìŠ¤í¬ë¦°ìƒ· ìƒì„± ê²°ê³¼ ---")
    UI.success("âœ… ì„±ê³µ: #{screenshot_results[:successful].join(', ')}") if screenshot_results[:successful].any?
    UI.error("âŒ ì‹¤íŒ¨: #{screenshot_results[:failed].map { |f| f[:app] }.join(', ')}") if screenshot_results[:failed].any?

    UI.message("
--- App Store ì—…ë¡œë“œ ê²°ê³¼ ---")
    UI.success("âœ… ì„±ê³µ: #{upload_results[:successful].join(', ')}") if upload_results[:successful].any?
    UI.error("âŒ ì‹¤íŒ¨: #{upload_results[:failed].map { |f| f[:app] }.join(', ')}") if upload_results[:failed].any?

    UI.message("
ğŸ‰ ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì™„ë£Œ!")
    UI.message("ğŸ’¡ App Store Connectì—ì„œ ë³€ê²½ì‚¬í•­ì„ í™•ì¸í•˜ì„¸ìš”: https://appstoreconnect.apple.com/")
  end

  def print_full_submit_summary(screenshot_results:, upload_results:, build_results:)
    UI.header("ğŸ“Š ì „ì²´ ë¹Œë“œ ë° ì œì¶œ ê²°ê³¼ ìš”ì•½")

    UI.message("
--- ìŠ¤í¬ë¦°ìƒ· ìƒì„± ê²°ê³¼ ---")
    UI.success("âœ… ì„±ê³µ: #{screenshot_results[:successful].join(', ')}") if screenshot_results[:successful].any?
    UI.error("âŒ ì‹¤íŒ¨: #{screenshot_results[:failed].map { |f| f[:app] }.join(', ')}") if screenshot_results[:failed].any?

    UI.message("
--- ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ê²°ê³¼ ---")
    UI.success("âœ… ì„±ê³µ: #{upload_results[:successful].join(', ')}") if upload_results[:successful].any?
    UI.error("âŒ ì‹¤íŒ¨: #{upload_results[:failed].map { |f| f[:app] }.join(', ')}") if upload_results[:failed].any?

    UI.message("
--- ì•± ë¹Œë“œ ë° ì œì¶œ ê²°ê³¼ ---")
    UI.success("âœ… ì„±ê³µ: #{build_results[:successful].join(', ')}") if build_results[:successful].any?
    UI.error("âŒ ì‹¤íŒ¨: #{build_results[:failed].map { |f| f[:app] }.join(', ')}") if build_results[:failed].any?

    total_apps = screenshot_results[:successful].length + screenshot_results[:failed].length
    successful_builds = build_results[:successful].length
    
    UI.message("
ğŸ‰ ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì™„ë£Œ!")
    UI.message("ğŸ“Š ìµœì¢… ê²°ê³¼: #{successful_builds}/#{total_apps} ì•±ì´ ì„±ê³µì ìœ¼ë¡œ ë¹Œë“œ ë° ì œì¶œë˜ì—ˆìŠµë‹ˆë‹¤")
    UI.message("ğŸ’¡ App Store Connectì—ì„œ ì œì¶œ ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”: https://appstoreconnect.apple.com/")
  end
end