default_platform(:ios)

# ì•± ì„¤ì • (í™˜ê²½ë³€ìˆ˜ ëŒ€ì‹  í•˜ë“œì½”ë”©ìœ¼ë¡œ ê°„ì†Œí™”)
APPS = {
  "Toffs" => "com.tamsadan.toolinder",
  "Plots" => "com.annapo.plotfolio",
  "Retros" => "com.annapo.kpt",
  "Multis" => "com.annapo.taskfolio",
  "Capts" => "com.folio.world.mulling.app.ios",
  "FewCuts" => "com.annapo.fewcuts",
}

# Tuist ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ê²½ë¡œ
WORKSPACE_NAME = "FewsWorkspace"

platform :ios do
  before_all do
    # API í‚¤ ì„¤ì • (ê°„ì†Œí™”)
    api_key_json = JSON.parse(File.read("api_key.json"))
    app_store_connect_api_key(
      key_id: api_key_json["key_id"],
      issuer_id: api_key_json["issuer_id"], 
      key_content: api_key_json["key"]
    )
    
    # xcodebuild íƒ€ì„ì•„ì›ƒ ì„¤ì • (ë³µì¡í•œ íŒ¨í‚¤ì§€ ì˜ì¡´ì„± ë•Œë¬¸ì— ì¦ê°€)
    ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
    ENV["FASTLANE_XCODEBUILD_SETTINGS_RETRIES"] = "2"
  end

  # Tuist í”„ë¡œì íŠ¸ ìƒì„± í—¬í¼ ë©”ì„œë“œ
  private_lane :generate do
    UI.message("ğŸ”§ Tuist í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤...")
    
    Dir.chdir("..") do
      sh("tuist install", error_callback: ->(result) {
        UI.message("Tuist install ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ìˆì—ˆì§€ë§Œ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤.")
      })
      sh("tuist generate --no-open")
    end
    
    UI.success("âœ… Tuist í”„ë¡œì íŠ¸ ìƒì„± ì™„ë£Œ!")
  end

  desc "Upload to TestFlight"
  lane :upload do
    app_names = APPS.keys
    UI.message("ì•±ì„ ì„ íƒí•˜ì„¸ìš”:")
    app_names.each_with_index { |name, i| UI.message("#{i+1}. #{name}") }
    
    choices_input = UI.input("ë²ˆí˜¸ ì„ íƒ (ì—¬ëŸ¬ê°œëŠ” ì½¤ë§ˆë¡œ êµ¬ë¶„, ì˜ˆ: 1,3,5): ")
    choices = choices_input.split(',').map(&:strip).map(&:to_i)
    
    # ì…ë ¥ê°’ ê²€ì¦
    invalid_choices = choices.reject { |choice| (1..app_names.length).include?(choice) }
    unless invalid_choices.empty?
      UI.error("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤: #{invalid_choices.join(', ')}")
      next
    end
    
    selected_apps = choices.map { |choice| app_names[choice-1] }
    UI.success("ì„ íƒëœ ì•±ë“¤: #{selected_apps.join(', ')}")
    
    # 1ë‹¨ê³„: ëª¨ë“  ì•±ì˜ ë²„ì „ ì •ë³´ë¥¼ ë¯¸ë¦¬ ì…ë ¥ë°›ê¸°
    UI.header("ğŸ“ 1ë‹¨ê³„: ë²„ì „ ì •ë³´ ì…ë ¥")
    app_versions = {}
    
    selected_apps.each do |app_name|
      plist_path = "Apps/#{app_name}/Resources/Info.plist"
      
      # plist íŒŒì¼ ê²½ë¡œ ì°¾ê¸°
      if !File.exist?(plist_path)
        alternative_paths = [
          "../Apps/#{app_name}/Resources/Info.plist",
          "#{app_name}/Resources/Info.plist",
          "../#{app_name}/Resources/Info.plist"
        ]
        
        alternative_paths.each do |alt_path|
          if File.exist?(alt_path)
            plist_path = File.expand_path(alt_path)
            break
          end
        end
      end
      
      if File.exist?(plist_path)
        current_version = get_info_plist_value(path: plist_path, key: "CFBundleShortVersionString")
        UI.message("#{app_name} í˜„ì¬ ë²„ì „: #{current_version}")
        
        version = UI.input("#{app_name}ì˜ ìƒˆ ë²„ì „ (í˜„ì¬ê°’ ìœ ì§€í•˜ë ¤ë©´ ì—”í„°): ")
        build = Time.now.strftime("%Y%m%d%H%M%S")
        
        app_versions[app_name] = {
          plist_path: plist_path,
          version: version.empty? ? current_version : version,
          build: build
        }
      else
        UI.error("#{app_name}ì˜ Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
        app_versions[app_name] = nil
      end
    end
    
    # ì…ë ¥ë°›ì€ ë²„ì „ ì •ë³´ í™•ì¸
    UI.header("ğŸ“‹ ì…ë ¥ëœ ë²„ì „ ì •ë³´ í™•ì¸")
    app_versions.each do |app_name, info|
      if info
        UI.message("#{app_name}: ë²„ì „ #{info[:version]}, ë¹Œë“œ #{info[:build]}")
      else
        UI.error("#{app_name}: ì„¤ì • ë¶ˆê°€ (Info.plist íŒŒì¼ ì—†ìŒ)")
      end
    end
    
    confirmation = UI.confirm("ìœ„ ì •ë³´ë¡œ ë¹Œë“œë¥¼ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
    unless confirmation
      UI.message("ë¹Œë“œê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
      next
    end
    
    # 2ë‹¨ê³„: ê° ì•±ì„ ìˆœì°¨ì ìœ¼ë¡œ ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ + ë¹Œë“œ/ì—…ë¡œë“œ
    UI.header("ğŸš€ 2ë‹¨ê³„: ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ë° ë¹Œë“œ/ì—…ë¡œë“œ")
    failed_metadata_apps = []
    failed_build_apps = []
    successful_apps = []
    
    selected_apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{selected_apps.length}: #{app_name} ì²˜ë¦¬ ì¤‘...")
      
      version_info = app_versions[app_name]
      unless version_info
        UI.error("âŒ #{app_name}: Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ê±´ë„ˆëœë‹ˆë‹¤.")
        failed_build_apps << app_name
        next
      end
      
      bundle_id = APPS[app_name]
      metadata_success = false
      build_success = false
      
      # 2-1. ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ
      UI.message("ğŸ“ #{app_name} ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì¤‘...")
      begin
        upload_to_app_store(
          app_identifier: bundle_id,
          skip_binary_upload: true,
          skip_screenshots: true,
          force: true,
          metadata_path: "./fastlane/metadata/#{app_name}"
        )
        metadata_success = true
        UI.success("âœ… #{app_name} ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì™„ë£Œ")
      rescue => error
        failed_metadata_apps << app_name
        UI.error("âŒ #{app_name} ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì‹¤íŒ¨: #{error.message}")
        UI.message("ë¹Œë“œëŠ” ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤...")
      end
      
      # 2-2. ë¹Œë“œ ë° ë°”ì´ë„ˆë¦¬ ì—…ë¡œë“œ
      UI.message("ğŸ”¨ #{app_name} ë¹Œë“œ ë° ë°”ì´ë„ˆë¦¬ ì—…ë¡œë“œ ì¤‘...")
      begin
        UI.message("ğŸ“ í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬: #{Dir.pwd}")
        UI.message("ğŸ“„ Info.plist ê²½ë¡œ: #{version_info[:plist_path]}")
        UI.message("ğŸ”¢ ì„¤ì •í•  ë²„ì „: #{version_info[:version]}, ë¹Œë“œ: #{version_info[:build]}")
        
        # ë²„ì „ ì •ë³´ ì„¤ì •
        set_info_plist_value(path: version_info[:plist_path], key: "CFBundleShortVersionString", value: version_info[:version])
        set_info_plist_value(path: version_info[:plist_path], key: "CFBundleVersion", value: version_info[:build])
        
        clear_derived_data
        generate
        
        ENV["ENABLE_USER_SCRIPT_SANDBOXING"] = "NO"
        
        sh("mkdir -p ./build")
        gym(
          workspace: "#{WORKSPACE_NAME}.xcworkspace",
          scheme: app_name,
          configuration: "Release",
          export_method: "app-store",
          clean: false,
          destination: "generic/platform=iOS",
          skip_package_dependencies_resolution: true,
          disable_package_automatic_updates: true,
          output_directory: "./build",
          output_name: app_name,
          xcargs: "-allowProvisioningUpdates -skipMacroValidation",
          export_options: {
            method: "app-store",
            compileBitcode: false,
            uploadBitcode: false,
            uploadSymbols: true,
            manageAppVersionAndBuildNumber: false
          }
        )
        
        upload_to_testflight(
          ipa: "./build/#{app_name}.ipa",
          skip_waiting_for_build_processing: true
        )
        
        build_success = true
        UI.success("âœ… #{app_name} ë¹Œë“œ ë° ì—…ë¡œë“œ ì™„ë£Œ")
        
      rescue => error
        failed_build_apps << app_name
        UI.error("âŒ #{app_name} ë¹Œë“œ/ì—…ë¡œë“œ ì‹¤íŒ¨: #{error.message}")
        UI.message("ë‹¤ìŒ ì•±ìœ¼ë¡œ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤...")
      end
      
      # ì „ì²´ ì„±ê³µ ì—¬ë¶€ í™•ì¸
      if metadata_success && build_success
        successful_apps << app_name
        UI.success("ğŸ‰ #{app_name} ì „ì²´ ê³¼ì • ì™„ë£Œ!")
      end
    end
    
    # ê²°ê³¼ ìš”ì•½
    UI.header("ğŸ“Š ì „ì²´ ê²°ê³¼ ìš”ì•½")
    
    if successful_apps.any?
      UI.success("ğŸ‰ ì „ì²´ ê³¼ì • ì„±ê³µ: #{successful_apps.join(', ')}")
    end
    
    if failed_metadata_apps.any?
      UI.error("ğŸ“ ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì‹¤íŒ¨: #{failed_metadata_apps.join(', ')}")
    end
    
    if failed_build_apps.any?
      UI.error("ğŸ”¨ ë¹Œë“œ/ì—…ë¡œë“œ ì‹¤íŒ¨: #{failed_build_apps.join(', ')}")
    end
    
    total_failed = (failed_metadata_apps + failed_build_apps).uniq
    if total_failed.empty?
      UI.success("ëª¨ë“  ì•± ì²˜ë¦¬ ì™„ë£Œ! ğŸš€")
    else
      UI.message("ì²˜ë¦¬ ì™„ë£Œ: #{successful_apps.length}/#{selected_apps.length} ì„±ê³µ")
      if failed_metadata_apps.any? && failed_build_apps.any?
        UI.message("ğŸ’¡ ì¼ë¶€ ì•±ì€ ë©”íƒ€ë°ì´í„°ë§Œ ì‹¤íŒ¨í•˜ê³  ë¹Œë“œëŠ” ì„±ê³µí–ˆì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
      end
    end
  end
  
  desc "Reset certificates"
  lane :reset do
    ["development", "appstore"].each do |type|
      match_nuke(type: type, app_identifier: APPS.values)
      match(type: type, app_identifier: APPS.values, readonly: false, username: "mooyoung2309@gmail.com")
    end
    UI.success("Certificates reset! ğŸ”")
  end
  

end