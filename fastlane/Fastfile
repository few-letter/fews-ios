# Refactored Fastfile
# frozen_string_literal: true

default_platform(:ios)

# --- Configuration ---

# App identifiers
APPS = {
  "Toffs" => "com.tamsadan.toolinder",
  "Plots" => "com.annapo.plotfolio",
  "Retros" => "com.annapo.kpt",
  "Multis" => "com.annapo.taskfolio",
  "Capts" => "com.folio.world.mulling.app.ios",
  "FewCuts" => "com.annapo.fewcuts",
}.freeze

# Tuist workspace name, located in the project root
WORKSPACE_NAME = "FewsWorkspace"
WORKSPACE_PATH = "../#{WORKSPACE_NAME}.xcworkspace".freeze

# CRITICAL: Screenshots path - DO NOT MODIFY THIS PATH
# This path is used throughout the application for screenshot upload
# Changing this path will break the screenshot upload functionality
SCREENSHOTS_PATH_TEMPLATE = "./fastlane/screenshots/%s/".freeze

# --- Lanes ---

platform :ios do
  # This is executed before any lane
  before_all do
    setup_environment
  end

  desc "App Storeì— ì•±ì„ ë¹Œë“œí•˜ê³  ì—…ë¡œë“œí•©ë‹ˆë‹¤. (ìŠ¤í¬ë¦°ìƒ· ìƒì„± ë° ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ í¬í•¨)"
  lane :upload do
    UI.header("ğŸš€ ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì‹œì‘: ìŠ¤í¬ë¦°ìƒ· ìƒì„± ë° App Store ì—…ë¡œë“œ")
    
    selected_apps = select_apps(all_apps: APPS.keys)
    break if selected_apps.empty?

    screenshot_results = generate_screenshots_for_apps(apps: selected_apps)
    upload_results = upload_app_details(apps: selected_apps)

    print_full_upload_summary(screenshot_results: screenshot_results, upload_results: upload_results)
  end

  desc "TestFlightì— ì•±ì„ ë¹Œë“œí•˜ê³  ì—…ë¡œë“œí•©ë‹ˆë‹¤."
  lane :testflight do
    deploy(
      is_testflight: true,
      title: "TestFlight ì—…ë¡œë“œ"
    )
  end

  desc "App Storeì— ë¦¬ë·°ë¥¼ ìœ„í•´ ì•±ì„ ë¹Œë“œí•˜ê³  ì œì¶œí•©ë‹ˆë‹¤."
  lane :submit_to_appstore do
    deploy(
      submit_for_review: true,
      title: "App Store ì œì¶œ"
    )
  end

  desc "App Storeì— ë©”íƒ€ë°ì´í„°ì™€ ìŠ¤í¬ë¦°ìƒ·ë§Œ ì—…ë¡œë“œí•©ë‹ˆë‹¤."
  lane :submit_to_appstore_info do
    UI.header("ğŸš€ App Store ë©”íƒ€ë°ì´í„° ë° ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ")
    
    selected_apps = select_apps(all_apps: APPS.keys)
    break if selected_apps.empty?

    app_versions = prompt_for_version_info(apps: selected_apps)
    confirmation = UI.input("ìœ„ ì •ë³´ë¡œ ì—…ë¡œë“œë¥¼ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ? (ì—”í„° ë˜ëŠ” y): ")
    break unless confirmation.empty? || confirmation.downcase.start_with?('y')

    update_version_info(app_versions: app_versions)
    screenshot_results = generate_screenshots_for_apps(apps: selected_apps)
    upload_results = upload_app_details(apps: selected_apps)

    print_full_upload_summary(screenshot_results: screenshot_results, upload_results: upload_results)
  end

  desc "ì¸ì¦ì„œë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤."
  lane :reset do
    ["development", "appstore"].each do |type|
      match_nuke(type: type, app_identifier: APPS.values)
      match(type: type, app_identifier: APPS.values, readonly: false, username: "mooyoung2309@gmail.com")
    end
    UI.success("âœ… ì¸ì¦ì„œ ì´ˆê¸°í™” ì™„ë£Œ! ğŸ”")
  end

  private_lane :deploy do |options|
    UI.header("ğŸš€ #{options[:title]} í”„ë¡œì„¸ìŠ¤ ì‹œì‘")
    
    selected_apps = select_apps(all_apps: APPS.keys)
    break if selected_apps.empty?

    app_versions = prompt_for_version_info(apps: selected_apps)
    break unless UI.confirm("ìœ„ ì •ë³´ë¡œ ë¹Œë“œë¥¼ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")

    results = { successful: [], failed: [], build_only_success: [] }
    selected_apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{selected_apps.length}: #{app_name} ì²˜ë¦¬ ì¤‘...")
      
      version_info = app_versions[app_name]
      unless version_info
        UI.error("âŒ #{app_name}: Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ê±´ë„ˆëœë‹ˆë‹¤.")
        results[:failed] << app_name
        next
      end

      begin
        ipa_path = build_and_archive_app(app_name: app_name, version_info: version_info)

        if options[:is_testflight]
          upload_to_testflight(ipa: ipa_path, skip_waiting_for_build_processing: true)
          UI.success("âœ… #{app_name} ë¹Œë“œ ë° TestFlight ì—…ë¡œë“œ ì™„ë£Œ")
          
          begin
            upload_metadata(app_name: app_name)
            results[:successful] << app_name
          rescue => e
            UI.error("âŒ #{app_name} ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì‹¤íŒ¨: #{e.message}")
            results[:build_only_success] << app_name
          end
        else
          submit_for_review(app_name: app_name, ipa_path: ipa_path)
          results[:successful] << app_name
        end
      rescue => e
        results[:failed] << app_name
        UI.error("âŒ #{app_name} ì²˜ë¦¬ ì‹¤íŒ¨: #{e.message}")
      end
    end

    print_deploy_summary(results: results, title: options[:title])
  end

  private_lane :generate do
    UI.message("ğŸ”§ Tuist í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤...")
    Dir.chdir("..") do # Move to project root to run tuist
      # í˜„ì¬ ë””ë ‰í† ë¦¬ í™•ì¸
      UI.message("ğŸ“ í˜„ì¬ ë””ë ‰í† ë¦¬: #{Dir.pwd}")
      
      # tuist clean ì‹¤í–‰ (ì‹¤íŒ¨í•´ë„ ê³„ì† ì§„í–‰)
      begin
        sh("tuist clean")
        UI.success("âœ… Tuist clean ì™„ë£Œ")
      rescue => e
        UI.message("âš ï¸ Tuist clean ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ìˆì—ˆì§€ë§Œ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤: #{e.message}")
      end
      
      # tuist install ì‹¤í–‰ (ì„±ê³µí•´ì•¼ ê³„ì† ì§„í–‰)
      UI.message("ğŸ“¦ Tuist ì¢…ì†ì„± ì„¤ì¹˜ ì¤‘...")
      begin
        sh("tuist install")
        UI.success("âœ… Tuist install ì™„ë£Œ")
      rescue => e
        UI.error("âŒ Tuist install ì‹¤íŒ¨: #{e.message}")
        raise "Tuist installì´ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ì¢…ì†ì„±ì„ í™•ì¸í•´ì£¼ì„¸ìš”."
      end
      
      # ì ì‹œ ëŒ€ê¸° (install ì™„ë£Œ í›„ íŒŒì¼ ì‹œìŠ¤í…œ ë™ê¸°í™”)
      sleep(2)
      
      # Package.resolved íŒŒì¼ ì¡´ì¬ í™•ì¸
      if File.exist?("Tuist/Package.resolved")
        UI.success("âœ… Package.resolved íŒŒì¼ í™•ì¸")
      else
        UI.error("âŒ Package.resolved íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤. installì´ ì™„ë£Œë˜ì§€ ì•Šì•˜ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
      end
      
      # tuist generate ì‹¤í–‰ (ì¬ì‹œë„ ë¡œì§ í¬í•¨)
      UI.message("ğŸ—ï¸ Tuist í”„ë¡œì íŠ¸ ìƒì„± ì¤‘...")
      generate_success = false
      retry_count = 0
      max_retries = 1
      
      begin
        sh("tuist generate --no-open")
        UI.success("âœ… Tuist generate ì™„ë£Œ")
        generate_success = true
      rescue => e
        retry_count += 1
        UI.error("âŒ Tuist generate ì‹¤íŒ¨ (#{retry_count}/#{max_retries + 1}): #{e.message}")
        
        if retry_count <= max_retries
          UI.message("â³ 3ì´ˆ í›„ ë‹¤ì‹œ ì‹œë„í•©ë‹ˆë‹¤...")
          sleep(3)
          retry
        else
          UI.error("âŒ Tuist generate ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì´ˆê³¼")
          raise "Tuist generateê°€ #{max_retries + 1}ë²ˆ ì‹œë„ ëª¨ë‘ ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: #{e.message}"
        end
      end
      
      # ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ ìƒì„± í™•ì¸
      workspace_file = "#{WORKSPACE_NAME}.xcworkspace"
      if File.exist?(workspace_file)
        UI.success("âœ… ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ ìƒì„± í™•ì¸: #{workspace_file}")
      else
        UI.error("âŒ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ì´ ìƒì„±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤: #{workspace_file}")
        raise "ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ ìƒì„± ì‹¤íŒ¨"
      end
    end
    UI.success("âœ… Tuist í”„ë¡œì íŠ¸ ìƒì„± ì™„ë£Œ!")
  end

  def setup_environment
    api_key_json = JSON.parse(File.read("api_key.json"))
    app_store_connect_api_key(
      key_id: api_key_json["key_id"],
      issuer_id: api_key_json["issuer_id"], 
      key_content: api_key_json["key"]
    )
    
    ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
    ENV["FASTLANE_XCODEBUILD_SETTINGS_RETRIES"] = "2"
    ENV["ENABLE_USER_SCRIPT_SANDBOXING"] = "NO"
    ENV["FASTLANE_ENABLE_BETA_DELIVER_SYNC_SCREENSHOTS"] = "true"
    ENV["FASTLANE_SCREENSHOT_PROCESSING_TIMEOUT"] = "120"
  end

  def select_apps(all_apps:)
    UI.message("ì•±ì„ ì„ íƒí•˜ì„¸ìš”:")
    all_apps.each_with_index { |name, i| UI.message("#{i+1}. #{name}") }
    
    choices_input = UI.input("ë²ˆí˜¸ ì„ íƒ (ì—¬ëŸ¬ê°œëŠ” ì½¤ë§ˆë¡œ êµ¬ë¶„, ì˜ˆ: 1,3,5): ")
    choices = choices_input.split(',').map(&:strip).map(&:to_i)
    
    invalid_choices = choices.reject { |c| (1..all_apps.length).include?(c) }
    unless invalid_choices.empty?
      UI.error("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤: #{invalid_choices.join(', ')}")
      return []
    end
    
    selected_apps = choices.map { |c| all_apps[c-1] }.uniq
    UI.success("ì„ íƒëœ ì•±: #{selected_apps.join(', ')}")
    selected_apps
  end

  def find_plist_path(app_name)
    path = "../Apps/#{app_name}/Resources/Info.plist"
    File.exist?(path) ? File.expand_path(path) : nil
  end

  def prompt_for_version_info(apps:)
    UI.header("ğŸ“ ë²„ì „ ì •ë³´ ì…ë ¥")
    app_versions = {}
    
    apps.each do |app_name|
      plist_path = find_plist_path(app_name)
      if plist_path
        current_version = get_info_plist_value(path: plist_path, key: "CFBundleShortVersionString")
        UI.message("#{app_name} í˜„ì¬ ë²„ì „: #{current_version}")
        
        version_input = UI.input("#{app_name}ì˜ ìƒˆ ë²„ì „ (í˜„ì¬ê°’ ìœ ì§€í•˜ë ¤ë©´ ì—”í„°): ")
        version = version_input.empty? ? current_version : version_input
        build = Time.now.strftime("%Y%m%d%H%M%S")
        
        app_versions[app_name] = { plist_path: plist_path, version: version, build: build }
      else
        UI.error("#{app_name}ì˜ Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
        app_versions[app_name] = nil
      end
    end
    
    UI.header("ğŸ“‹ ì…ë ¥ëœ ë²„ì „ ì •ë³´ í™•ì¸")
    app_versions.each do |app, info|
      info ? UI.message("#{app}: ë²„ì „ #{info[:version]}, ë¹Œë“œ #{info[:build]}") : UI.error("#{app}: ì„¤ì • ë¶ˆê°€")
    end
    
    app_versions
  end

  def update_version_info(app_versions:)
    UI.header("ğŸ”„ ë²„ì „ ì •ë³´ ì—…ë°ì´íŠ¸ ì¤‘...")
    
    app_versions.each do |app_name, version_info|
      next unless version_info
      
      UI.message("ğŸ“ #{app_name} ë²„ì „ ì—…ë°ì´íŠ¸: #{version_info[:version]}, ë¹Œë“œ: #{version_info[:build]}")
      set_info_plist_value(path: version_info[:plist_path], key: "CFBundleShortVersionString", value: version_info[:version])
      set_info_plist_value(path: version_info[:plist_path], key: "CFBundleVersion", value: version_info[:build])
    end
    
    UI.success("âœ… ëª¨ë“  ì•±ì˜ ë²„ì „ ì •ë³´ ì—…ë°ì´íŠ¸ ì™„ë£Œ")
  end

  def build_and_archive_app(app_name:, version_info:)
    UI.message("ğŸ”¨ #{app_name} ë¹Œë“œ ë° ì•„ì¹´ì´ë¸Œ ì¤‘...")
    
    set_info_plist_value(path: version_info[:plist_path], key: "CFBundleShortVersionString", value: version_info[:version])
    set_info_plist_value(path: version_info[:plist_path], key: "CFBundleVersion", value: version_info[:build])
    
    clear_derived_data
    generate
    
    # ì¸ì¦ì„œ ì„¤ì •
    UI.message("ğŸ” ì¸ì¦ì„œ ì„¤ì • ì¤‘...")
    match(
      type: "appstore",
      app_identifier: APPS[app_name],
      readonly: true,
      keychain_name: "login.keychain",
      keychain_password: ""
    )
    
    output_path = "./build"
    sh("mkdir -p #{output_path}")
    
    # ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ì˜ ì ˆëŒ€ ê²½ë¡œ í™•ì¸
    workspace_path = File.expand_path(WORKSPACE_PATH)
    UI.message("ğŸ” ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ê²½ë¡œ: #{workspace_path}")
    
    unless File.exist?(workspace_path)
      UI.error("âŒ ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{workspace_path}")
      raise "ì›Œí¬ìŠ¤í˜ì´ìŠ¤ íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{workspace_path}"
    end
    
    gym(
      workspace: workspace_path,
      scheme: app_name,
      configuration: "Release",
      export_method: "app-store",
      clean: false,
      destination: "generic/platform=iOS",
      skip_package_dependencies_resolution: true,
      disable_package_automatic_updates: true,
      output_directory: output_path,
      output_name: app_name,
      xcargs: "-allowProvisioningUpdates -skipMacroValidation",
      export_options: {
        method: "app-store",
        compileBitcode: false,
        uploadBitcode: false,
        uploadSymbols: true,
        manageAppVersionAndBuildNumber: false,
        provisioningProfiles: {
          APPS[app_name] => "match AppStore #{APPS[app_name]}"
        }
      }
    )
    
    UI.success("âœ… #{app_name} ë¹Œë“œ ì™„ë£Œ")
    "#{output_path}/#{app_name}.ipa"
  end

  def upload_metadata(app_name:)
    UI.message("ğŸ“ #{app_name} ë©”íƒ€ë°ì´í„° ë° ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ ì¤‘...")
    upload_to_app_store(
      app_identifier: APPS[app_name],
      skip_binary_upload: true,
      skip_screenshots: false,
      force: true,
      ignore_language_directory_validation: true,
      metadata_path: "./metadata/#{app_name}",
      screenshots_path: SCREENSHOTS_PATH_TEMPLATE % app_name,
      sync_screenshots: true
    )
    UI.success("âœ… #{app_name} ë©”íƒ€ë°ì´í„° ë° ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ ì™„ë£Œ")
  end

  def submit_for_review(app_name:, ipa_path:)
    UI.message("ğŸš€ #{app_name} App Store ì œì¶œ ì¤‘...")
    upload_to_app_store(
      ipa: ipa_path,
      app_identifier: APPS[app_name],
      submit_for_review: true,
      automatic_release: true,
      force: true,
      skip_screenshots: true,
      run_precheck_before_submit: true,
      ignore_language_directory_validation: true,
      metadata_path: "./metadata/#{app_name}",
      submission_information: { 
        export_compliance_uses_encryption: false,
        add_id_info_uses_idfa: false 
      }
    )
    UI.success("âœ… #{app_name} App Store ì œì¶œ ì™„ë£Œ")
  end

  def print_deploy_summary(results:, title:)
    UI.header("ğŸ“Š #{title} ê²°ê³¼ ìš”ì•½")
    
    UI.success("ğŸ‰ ì „ì²´ ê³¼ì • ì„±ê³µ: #{results[:successful].join(', ')}") if results[:successful].any?
    UI.message("âš ï¸ ë¹Œë“œ ì„±ê³µ, ë©”íƒ€ë°ì´í„° ì‹¤íŒ¨: #{results[:build_only_success].join(', ')}") if results[:build_only_success].any?
    UI.error("âŒ ë¹Œë“œ/ì—…ë¡œë“œ ì‹¤íŒ¨: #{results[:failed].join(', ')}") if results[:failed].any?
    
    total = results[:successful].length + results[:build_only_success].length + results[:failed].length
    total_success = results[:successful].length + results[:build_only_success].length
    
    if results[:failed].empty?
      UI.success("ëª¨ë“  ì•± ì²˜ë¦¬ ì™„ë£Œ! ğŸš€")
    else
      UI.message("ë¹Œë“œ ì™„ë£Œ: #{total_success}/#{total} ì„±ê³µ")
    end
  end

  def generate_screenshots_for_apps(apps:)
    UI.header("ğŸ¯ 1ë‹¨ê³„: ìŠ¤í¬ë¦°ìƒ· ìƒì„±")
    results = { successful: [], failed: [] }
    
    apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{apps.length}: #{app_name} ìŠ¤í¬ë¦°ìƒ· ìƒì„± ì¤‘...")
      begin

        run_screenshot_generator(app_name)
        results[:successful] << app_name
        UI.success("âœ… #{app_name} ìŠ¤í¬ë¦°ìƒ· ìƒì„± ë° ë³µì‚¬ ì™„ë£Œ!")
      rescue => e
        results[:failed] << { app: app_name, reason: e.message }
        UI.error("âŒ #{app_name} ìŠ¤í¬ë¦°ìƒ· ìƒì„± ì‹¤íŒ¨: #{e.message}")
      end
    end
    results
  end

  def run_screenshot_generator(app_name)
    xmakes_dir = "../xmakes"
    raise "xmakes í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{xmakes_dir}" unless Dir.exist?(xmakes_dir)

    venv_python_relative_to_appstore = "../venv/bin/python"
    xmakes_appstore_dir = File.join(xmakes_dir, "appstore")
    
    unless File.exist?(File.join(xmakes_appstore_dir, venv_python_relative_to_appstore))
      raise "Python ê°€ìƒí™˜ê²½ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. `cd ../xmakes && python3 setup_venv.py`ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”."
    end

    Dir.chdir(xmakes_appstore_dir) do
      sh("rm -rf output") if Dir.exist?("output")
      sh("#{venv_python_relative_to_appstore} run_appstore_preview.py #{app_name}")
      copy_screenshots(app_name: app_name)
    end
  end

  def copy_screenshots(app_name:)
    UI.message("ğŸ“ ìŠ¤í¬ë¦°ìƒ· ë³µì‚¬ ì¤‘...")
    source_dir = "output/#{app_name}"
    raise "ìƒì„±ëœ ìŠ¤í¬ë¦°ìƒ· í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{source_dir}" unless Dir.exist?(source_dir)

    project_root = File.expand_path("../..")
    
    target_app_dir = File.join(project_root, "fastlane", "screenshots", app_name)
    sh("rm -rf '#{target_app_dir}'") if Dir.exist?(target_app_dir)
    sh("mkdir -p '#{target_app_dir}'")

    metadata_locales = Dir.glob(File.join(project_root, "fastlane", "metadata", app_name, "*")).select { |f| File.directory?(f) }.map { |f| File.basename(f) }

    generated_locales = Dir.glob("#{source_dir}/*/*").select { |f| File.directory?(f) }.map { |f| File.basename(f) }

    all_locales = (metadata_locales + generated_locales).uniq
    all_locales.each do |locale|
      target_lang_dir = File.join(target_app_dir, locale)
      sh("mkdir -p '#{target_lang_dir}'")
      UI.message("ğŸ“ #{locale} ìŠ¤í¬ë¦°ìƒ· ë””ë ‰í† ë¦¬ ìƒì„±.")
    end

    Dir.glob("#{source_dir}/*/*").each do |lang_dir|
      next unless File.directory?(lang_dir)
      lang_code = File.basename(lang_dir)
      target_lang_dir = File.join(target_app_dir, lang_code)
      
      png_files = Dir.glob("#{lang_dir}/*.png")
      if png_files.empty?
        UI.message("âš ï¸  #{lang_code}: ë³µì‚¬í•  PNG ìŠ¤í¬ë¦°ìƒ·ì´ ì—†ìŠµë‹ˆë‹¤.")
        next
      end
      
      sh("cp '#{lang_dir}'/*.png '#{target_lang_dir}/'")
      UI.message("ğŸ“¸ #{lang_code} ìŠ¤í¬ë¦°ìƒ· ë³µì‚¬ ì™„ë£Œ.")
    end
  end

  def upload_app_details(apps:)
    UI.header("ğŸ¯ 2ë‹¨ê³„: ë©”íƒ€ë°ì´í„° ë° ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ")
    results = { successful: [], failed: [] }

    apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{apps.length}: #{app_name} ì—…ë¡œë“œ ì¤‘...")
      begin
        plist_path = find_plist_path(app_name)
        raise "Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤." unless plist_path

        version = get_info_plist_value(path: plist_path, key: "CFBundleShortVersionString")
        build = Time.now.strftime("%Y%m%d%H%M%S")
        set_info_plist_value(path: plist_path, key: "CFBundleVersion", value: build)
        UI.message("ğŸ”¢ #{app_name} ë²„ì „: #{version}, ìƒˆ ë¹Œë“œ: #{build}")

        screenshots_path = SCREENSHOTS_PATH_TEMPLATE % app_name
        has_screenshots = Dir.exist?(screenshots_path) && !Dir.glob("#{screenshots_path}/**/*.{jpg,png,jpeg}").empty?

        upload_to_app_store(
          app_identifier: APPS[app_name],
          app_version: version,
          skip_binary_upload: true,
          force: true,
          metadata_path: "./metadata/#{app_name}",
          screenshots_path: SCREENSHOTS_PATH_TEMPLATE % app_name,
          skip_screenshots: false,
          sync_screenshots: true,
          ignore_language_directory_validation: true,
          precheck_include_in_app_purchases: false,
          run_precheck_before_submit: false
        )
        
        results[:successful] << app_name
        UI.success("âœ… #{app_name} ì—…ë¡œë“œ ì™„ë£Œ!")
      rescue => e
        if e.message.include?("Failed verification of all screenshots deleted")
          UI.important("âš ï¸ #{app_name} ìŠ¤í¬ë¦°ìƒ· ì‚­ì œ í™•ì¸ ì‹¤íŒ¨: #{e.message}")
          UI.important("ì´ ë¬¸ì œëŠ” Fastlaneì˜ ì•Œë ¤ì§„ ë™ì‘ì´ë©°, ì—…ë¡œë“œëŠ” ê³„ì†ë©ë‹ˆë‹¤.")
          UI.important("ì‹¤ì œ ì—…ë¡œë“œëŠ” ì„±ê³µí•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ App Store Connectì—ì„œ í™•ì¸í•˜ì„¸ìš”.")
          results[:successful] << app_name # Consider it successful for the purpose of the overall lane
        elsif e.message.include?("screenshot") && e.message.include?("delete")
          UI.important("âš ï¸ #{app_name} ìŠ¤í¬ë¦°ìƒ· ê´€ë ¨ ì˜¤ë¥˜: #{e.message}")
          UI.important("ì´ ë¬¸ì œëŠ” Fastlaneì˜ ì•Œë ¤ì§„ ë™ì‘ì´ë©°, ì—…ë¡œë“œëŠ” ê³„ì†ë©ë‹ˆë‹¤.")
          results[:successful] << app_name
        else
          results[:failed] << { app: app_name, reason: e.message }
          UI.error("âŒ #{app_name} ì—…ë¡œë“œ ì‹¤íŒ¨: #{e.message}")
        end
      end
    end
    results
  end

  def print_full_upload_summary(screenshot_results:, upload_results:)
    UI.header("ğŸ“Š ì „ì²´ í”„ë¡œì„¸ìŠ¤ ê²°ê³¼ ìš”ì•½")

    UI.message("
--- ìŠ¤í¬ë¦°ìƒ· ìƒì„± ê²°ê³¼ ---")
    UI.success("âœ… ì„±ê³µ: #{screenshot_results[:successful].join(', ')}") if screenshot_results[:successful].any?
    UI.error("âŒ ì‹¤íŒ¨: #{screenshot_results[:failed].map { |f| f[:app] }.join(', ')}") if screenshot_results[:failed].any?

    UI.message("
--- App Store ì—…ë¡œë“œ ê²°ê³¼ ---")
    UI.success("âœ… ì„±ê³µ: #{upload_results[:successful].join(', ')}") if upload_results[:successful].any?
    UI.error("âŒ ì‹¤íŒ¨: #{upload_results[:failed].map { |f| f[:app] }.join(', ')}") if upload_results[:failed].any?

    UI.message("
ğŸ‰ ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì™„ë£Œ!")
    UI.message("ğŸ’¡ App Store Connectì—ì„œ ë³€ê²½ì‚¬í•­ì„ í™•ì¸í•˜ì„¸ìš”: https://appstoreconnect.apple.com/")
  end
end