default_platform(:ios)

# ì•± ì„¤ì • (í™˜ê²½ë³€ìˆ˜ ëŒ€ì‹  í•˜ë“œì½”ë”©ìœ¼ë¡œ ê°„ì†Œí™”)
APPS = {
  "Toffs" => "com.tamsadan.toolinder",
  "Plots" => "com.annapo.plotfolio",
  "Retros" => "com.annapo.kpt",
  "Multis" => "com.annapo.taskfolio",
  "Capts" => "com.folio.world.mulling.app.ios",
  "FewCuts" => "com.annapo.fewcuts",
}

# Tuist ì›Œí¬ìŠ¤í˜ì´ìŠ¤ ê²½ë¡œ
WORKSPACE_NAME = "FewsWorkspace"

platform :ios do
  before_all do
    # API í‚¤ ì„¤ì • (ê°„ì†Œí™”)
    api_key_json = JSON.parse(File.read("api_key.json"))
    app_store_connect_api_key(
      key_id: api_key_json["key_id"],
      issuer_id: api_key_json["issuer_id"], 
      key_content: api_key_json["key"]
    )
    
    # xcodebuild íƒ€ì„ì•„ì›ƒ ì„¤ì • (ë³µì¡í•œ íŒ¨í‚¤ì§€ ì˜ì¡´ì„± ë•Œë¬¸ì— ì¦ê°€)
    ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
    ENV["FASTLANE_XCODEBUILD_SETTINGS_RETRIES"] = "2"
  end

  # Tuist í”„ë¡œì íŠ¸ ìƒì„± í—¬í¼ ë©”ì„œë“œ
  private_lane :generate do
    UI.message("ğŸ”§ Tuist í”„ë¡œì íŠ¸ë¥¼ ìƒì„±í•©ë‹ˆë‹¤...")
    
    Dir.chdir("..") do
      sh("tuist install", error_callback: ->(result) {
        UI.message("Tuist install ì‹¤í–‰ ì¤‘ ì˜¤ë¥˜ê°€ ìˆì—ˆì§€ë§Œ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤.")
      })
      sh("tuist generate --no-open")
    end
    
    UI.success("âœ… Tuist í”„ë¡œì íŠ¸ ìƒì„± ì™„ë£Œ!")
  end

  desc "Upload to TestFlight"
  lane :upload do
    app_names = APPS.keys
    UI.message("ì•±ì„ ì„ íƒí•˜ì„¸ìš”:")
    app_names.each_with_index { |name, i| UI.message("#{i+1}. #{name}") }
    
    choices_input = UI.input("ë²ˆí˜¸ ì„ íƒ (ì—¬ëŸ¬ê°œëŠ” ì½¤ë§ˆë¡œ êµ¬ë¶„, ì˜ˆ: 1,3,5): ")
    choices = choices_input.split(',').map(&:strip).map(&:to_i)
    
    # ì…ë ¥ê°’ ê²€ì¦
    invalid_choices = choices.reject { |choice| (1..app_names.length).include?(choice) }
    unless invalid_choices.empty?
      UI.error("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤: #{invalid_choices.join(', ')}")
      next
    end
    
    selected_apps = choices.map { |choice| app_names[choice-1] }
    UI.success("ì„ íƒëœ ì•±ë“¤: #{selected_apps.join(', ')}")
    
    # 1ë‹¨ê³„: ëª¨ë“  ì•±ì˜ ë²„ì „ ì •ë³´ë¥¼ ë¯¸ë¦¬ ì…ë ¥ë°›ê¸°
    UI.header("ğŸ“ 1ë‹¨ê³„: ë²„ì „ ì •ë³´ ì…ë ¥")
    app_versions = {}
    
    selected_apps.each do |app_name|
      plist_path = "Apps/#{app_name}/Resources/Info.plist"
      
      # plist íŒŒì¼ ê²½ë¡œ ì°¾ê¸°
      if !File.exist?(plist_path)
        alternative_paths = [
          "../Apps/#{app_name}/Resources/Info.plist",
          "#{app_name}/Resources/Info.plist",
          "../#{app_name}/Resources/Info.plist"
        ]
        
        alternative_paths.each do |alt_path|
          if File.exist?(alt_path)
            plist_path = File.expand_path(alt_path)
            break
          end
        end
      end
      
      if File.exist?(plist_path)
        current_version = get_info_plist_value(path: plist_path, key: "CFBundleShortVersionString")
        UI.message("#{app_name} í˜„ì¬ ë²„ì „: #{current_version}")
        
        version = UI.input("#{app_name}ì˜ ìƒˆ ë²„ì „ (í˜„ì¬ê°’ ìœ ì§€í•˜ë ¤ë©´ ì—”í„°): ")
        build = Time.now.strftime("%Y%m%d%H%M%S")
        
        app_versions[app_name] = {
          plist_path: plist_path,
          version: version.empty? ? current_version : version,
          build: build
        }
      else
        UI.error("#{app_name}ì˜ Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
        app_versions[app_name] = nil
      end
    end
    
    # ì…ë ¥ë°›ì€ ë²„ì „ ì •ë³´ í™•ì¸
    UI.header("ğŸ“‹ ì…ë ¥ëœ ë²„ì „ ì •ë³´ í™•ì¸")
    app_versions.each do |app_name, info|
      if info
        UI.message("#{app_name}: ë²„ì „ #{info[:version]}, ë¹Œë“œ #{info[:build]}")
      else
        UI.error("#{app_name}: ì„¤ì • ë¶ˆê°€ (Info.plist íŒŒì¼ ì—†ìŒ)")
      end
    end
    
    confirmation = UI.confirm("ìœ„ ì •ë³´ë¡œ ë¹Œë“œë¥¼ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
    unless confirmation
      UI.message("ë¹Œë“œê°€ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
      next
    end
    
    # 2ë‹¨ê³„: ê° ì•±ì„ ìˆœì°¨ì ìœ¼ë¡œ ë¹Œë“œ/ì—…ë¡œë“œ + ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ
    UI.header("ğŸš€ 2ë‹¨ê³„: ë¹Œë“œ/ì—…ë¡œë“œ ë° ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ")
    failed_metadata_apps = []
    failed_build_apps = []
    successful_apps = []
    
    selected_apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{selected_apps.length}: #{app_name} ì²˜ë¦¬ ì¤‘...")
      
      version_info = app_versions[app_name]
      unless version_info
        UI.error("âŒ #{app_name}: Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ê±´ë„ˆëœë‹ˆë‹¤.")
        failed_build_apps << app_name
        next
      end
      
      bundle_id = APPS[app_name]
      build_success = false
      metadata_success = false
      
      # 2-1. ë¹Œë“œ ë° ë°”ì´ë„ˆë¦¬ ì—…ë¡œë“œ (ë¨¼ì € ì‹¤í–‰)
      UI.message("ğŸ”¨ #{app_name} ë¹Œë“œ ë° ë°”ì´ë„ˆë¦¬ ì—…ë¡œë“œ ì¤‘...")
      begin
        UI.message("ğŸ“ í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬: #{Dir.pwd}")
        UI.message("ğŸ“„ Info.plist ê²½ë¡œ: #{version_info[:plist_path]}")
        UI.message("ğŸ”¢ ì„¤ì •í•  ë²„ì „: #{version_info[:version]}, ë¹Œë“œ: #{version_info[:build]}")
        
        # ë²„ì „ ì •ë³´ ì„¤ì •
        set_info_plist_value(path: version_info[:plist_path], key: "CFBundleShortVersionString", value: version_info[:version])
        set_info_plist_value(path: version_info[:plist_path], key: "CFBundleVersion", value: version_info[:build])
        
        clear_derived_data
        generate
        
        ENV["ENABLE_USER_SCRIPT_SANDBOXING"] = "NO"
        
        sh("mkdir -p ./build")
        gym(
          workspace: "#{WORKSPACE_NAME}.xcworkspace",
          scheme: app_name,
          configuration: "Release",
          export_method: "app-store",
          clean: false,
          destination: "generic/platform=iOS",
          skip_package_dependencies_resolution: true,
          disable_package_automatic_updates: true,
          output_directory: "./build",
          output_name: app_name,
          xcargs: "-allowProvisioningUpdates -skipMacroValidation",
          export_options: {
            method: "app-store",
            compileBitcode: false,
            uploadBitcode: false,
            uploadSymbols: true,
            manageAppVersionAndBuildNumber: false
          }
        )
        
        upload_to_testflight(
          ipa: "./build/#{app_name}.ipa",
          skip_waiting_for_build_processing: true
        )
        
        build_success = true
        UI.success("âœ… #{app_name} ë¹Œë“œ ë° ì—…ë¡œë“œ ì™„ë£Œ")
        
      rescue => error
        failed_build_apps << app_name
        UI.error("âŒ #{app_name} ë¹Œë“œ/ì—…ë¡œë“œ ì‹¤íŒ¨: #{error.message}")
        UI.message("ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œëŠ” ê±´ë„ˆë›°ê³  ë‹¤ìŒ ì•±ìœ¼ë¡œ ì§„í–‰í•©ë‹ˆë‹¤...")
        next
      end
      
      # 2-2. ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ (ë¹Œë“œ ì„±ê³µ í›„ ì‹¤í–‰)
      UI.message("ğŸ“ #{app_name} ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì¤‘...")
      begin
        upload_to_app_store(
          app_identifier: bundle_id,
          skip_binary_upload: true,
          skip_screenshots: true,
          force: true,
          ignore_language_directory_validation: true,
          metadata_path: "./fastlane/metadata/#{app_name}"
        )
        metadata_success = true
        UI.success("âœ… #{app_name} ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì™„ë£Œ")
      rescue => error
        failed_metadata_apps << app_name
        UI.error("âŒ #{app_name} ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì‹¤íŒ¨: #{error.message}")
        UI.message("ë¹Œë“œëŠ” ì´ë¯¸ ì„±ê³µí–ˆìœ¼ë¯€ë¡œ TestFlightì—ì„œ í™•ì¸ ê°€ëŠ¥í•©ë‹ˆë‹¤.")
      end
      
      # ì „ì²´ ì„±ê³µ ì—¬ë¶€ í™•ì¸
      if build_success && metadata_success
        successful_apps << app_name
        UI.success("ğŸ‰ #{app_name} ì „ì²´ ê³¼ì • ì™„ë£Œ!")
      elsif build_success
        UI.message("âš ï¸ #{app_name} ë¹Œë“œëŠ” ì„±ê³µí–ˆì§€ë§Œ ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì‹¤íŒ¨")
      end
    end
    
    # ê²°ê³¼ ìš”ì•½
    UI.header("ğŸ“Š ì „ì²´ ê²°ê³¼ ìš”ì•½")
    
    if successful_apps.any?
      UI.success("ğŸ‰ ì „ì²´ ê³¼ì • ì„±ê³µ: #{successful_apps.join(', ')}")
    end
    
    # ë¹Œë“œëŠ” ì„±ê³µí–ˆì§€ë§Œ ë©”íƒ€ë°ì´í„°ë§Œ ì‹¤íŒ¨í•œ ì•±ë“¤
    build_only_success = failed_metadata_apps - failed_build_apps
    if build_only_success.any?
      UI.message("âš ï¸ ë¹Œë“œ ì„±ê³µ + ë©”íƒ€ë°ì´í„° ì‹¤íŒ¨: #{build_only_success.join(', ')}")
      UI.message("ğŸ’¡ ì´ ì•±ë“¤ì€ TestFlightì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
    end
    
    if failed_build_apps.any?
      UI.error("ğŸ”¨ ë¹Œë“œ/ì—…ë¡œë“œ ì‹¤íŒ¨: #{failed_build_apps.join(', ')}")
    end
    
    total_build_success = selected_apps.length - failed_build_apps.length
    if failed_build_apps.empty?
      UI.success("ëª¨ë“  ì•± ë¹Œë“œ ì™„ë£Œ! ğŸš€")
    else
      UI.message("ë¹Œë“œ ì™„ë£Œ: #{total_build_success}/#{selected_apps.length} ì„±ê³µ")
    end
  end
  
  desc "Build and submit to App Store for review"
  lane :submit_to_appstore do
    app_names = APPS.keys
    UI.message("App Storeì— ë¹Œë“œ ë° ì œì¶œí•  ì•±ì„ ì„ íƒí•˜ì„¸ìš”:")
    app_names.each_with_index { |name, i| UI.message("#{i+1}. #{name}") }
    
    choices_input = UI.input("ë²ˆí˜¸ ì„ íƒ (ì—¬ëŸ¬ê°œëŠ” ì½¤ë§ˆë¡œ êµ¬ë¶„, ì˜ˆ: 1,3,5): ")
    choices = choices_input.split(',').map(&:strip).map(&:to_i)
    
    # ì…ë ¥ê°’ ê²€ì¦
    invalid_choices = choices.reject { |choice| (1..app_names.length).include?(choice) }
    unless invalid_choices.empty?
      UI.error("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤: #{invalid_choices.join(', ')}")
      next
    end
    
    selected_apps = choices.map { |choice| app_names[choice-1] }
    UI.success("ì„ íƒëœ ì•±ë“¤: #{selected_apps.join(', ')}")
    UI.message("ğŸš€ ìë™ ì¶œì‹œë¡œ ì„¤ì •ë©ë‹ˆë‹¤ (ìŠ¹ì¸ ì¦‰ì‹œ ìë™ ì¶œì‹œ)")
    
    # 1ë‹¨ê³„: ëª¨ë“  ì•±ì˜ ë²„ì „ ì •ë³´ë¥¼ ë¯¸ë¦¬ ì…ë ¥ë°›ê¸°
    UI.header("ğŸ“ 1ë‹¨ê³„: ë²„ì „ ì •ë³´ ì…ë ¥")
    app_versions = {}
    
    selected_apps.each do |app_name|
      plist_path = "Apps/#{app_name}/Resources/Info.plist"
      
      # plist íŒŒì¼ ê²½ë¡œ ì°¾ê¸°
      if !File.exist?(plist_path)
        alternative_paths = [
          "../Apps/#{app_name}/Resources/Info.plist",
          "#{app_name}/Resources/Info.plist",
          "../#{app_name}/Resources/Info.plist"
        ]
        
        alternative_paths.each do |alt_path|
          if File.exist?(alt_path)
            plist_path = File.expand_path(alt_path)
            break
          end
        end
      end
      
      if File.exist?(plist_path)
        current_version = get_info_plist_value(path: plist_path, key: "CFBundleShortVersionString")
        UI.message("#{app_name} í˜„ì¬ ë²„ì „: #{current_version}")
        
        version = UI.input("#{app_name}ì˜ ìƒˆ ë²„ì „ (í˜„ì¬ê°’ ìœ ì§€í•˜ë ¤ë©´ ì—”í„°): ")
        build = Time.now.strftime("%Y%m%d%H%M%S")
        
        app_versions[app_name] = {
          plist_path: plist_path,
          version: version.empty? ? current_version : version,
          build: build
        }
      else
        UI.error("#{app_name}ì˜ Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
        app_versions[app_name] = nil
      end
    end
    
    # ì…ë ¥ë°›ì€ ë²„ì „ ì •ë³´ í™•ì¸
    UI.header("ğŸ“‹ ì…ë ¥ëœ ë²„ì „ ì •ë³´ í™•ì¸")
    app_versions.each do |app_name, info|
      if info
        UI.message("#{app_name}: ë²„ì „ #{info[:version]}, ë¹Œë“œ #{info[:build]}")
      else
        UI.error("#{app_name}: ì„¤ì • ë¶ˆê°€ (Info.plist íŒŒì¼ ì—†ìŒ)")
      end
    end
    
    confirmation = UI.confirm("ìœ„ ì •ë³´ë¡œ ë¹Œë“œ ë° App Store ì œì¶œì„ ì‹œì‘í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
    unless confirmation
      UI.message("App Store ì œì¶œì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
      next
    end
    
    # 2ë‹¨ê³„: ê° ì•±ì„ ìˆœì°¨ì ìœ¼ë¡œ ë¹Œë“œ + í†µí•© App Store ì œì¶œ (ë©”íƒ€ë°ì´í„° í¬í•¨)
    UI.header("ğŸš€ 2ë‹¨ê³„: ë¹Œë“œ ë° App Store ì œì¶œ (ë©”íƒ€ë°ì´í„° í†µí•©)")
    failed_apps = []
    successful_apps = []
    
    selected_apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{selected_apps.length}: #{app_name} ì²˜ë¦¬ ì¤‘...")
      
      version_info = app_versions[app_name]
      unless version_info
        UI.error("âŒ #{app_name}: Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ê±´ë„ˆëœë‹ˆë‹¤.")
        failed_apps << app_name
        next
      end
      
      bundle_id = APPS[app_name]
      
      # ë¹Œë“œ ë° í†µí•© App Store ì œì¶œ (ë©”íƒ€ë°ì´í„° í¬í•¨)
      UI.message("ğŸ”¨ #{app_name} ë¹Œë“œ ë° App Store ì œì¶œ ì¤‘ (ë©”íƒ€ë°ì´í„° í¬í•¨)...")
      begin
        UI.message("ğŸ“ í˜„ì¬ ì‘ì—… ë””ë ‰í† ë¦¬: #{Dir.pwd}")
        UI.message("ğŸ“„ Info.plist ê²½ë¡œ: #{version_info[:plist_path]}")
        UI.message("ğŸ”¢ ì„¤ì •í•  ë²„ì „: #{version_info[:version]}, ë¹Œë“œ: #{version_info[:build]}")
        
        # ë²„ì „ ì •ë³´ ì„¤ì •
        set_info_plist_value(path: version_info[:plist_path], key: "CFBundleShortVersionString", value: version_info[:version])
        set_info_plist_value(path: version_info[:plist_path], key: "CFBundleVersion", value: version_info[:build])
        
        clear_derived_data
        generate
        
        ENV["ENABLE_USER_SCRIPT_SANDBOXING"] = "NO"
        
        sh("mkdir -p ./build")
        gym(
          workspace: "#{WORKSPACE_NAME}.xcworkspace",
          scheme: app_name,
          configuration: "Release",
          export_method: "app-store",
          clean: false,
          destination: "generic/platform=iOS",
          skip_package_dependencies_resolution: true,
          disable_package_automatic_updates: true,
          output_directory: "./build",
          output_name: app_name,
          xcargs: "-allowProvisioningUpdates -skipMacroValidation",
          export_options: {
            method: "app-store",
            compileBitcode: false,
            uploadBitcode: false,
            uploadSymbols: true,
            manageAppVersionAndBuildNumber: false
          }
        )
        
        # ë¹Œë“œì™€ ë©”íƒ€ë°ì´í„°ë¥¼ í•œ ë²ˆì— App Storeì— ì œì¶œ
        upload_to_app_store(
          ipa: "./build/#{app_name}.ipa",
          submit_for_review: true,
          automatic_release: true,
          force: true, # HTML ë¯¸ë¦¬ë³´ê¸° ê±´ë„ˆë›°ê¸°
          skip_screenshots: true, # ìŠ¤í¬ë¦°ìƒ· ì—…ë°ì´íŠ¸ ê±´ë„ˆë›°ê¸°
          run_precheck_before_submit: true, # ì œì¶œ ì „ ì‚¬ì „ ê²€ì‚¬ ì‹¤í–‰
          ignore_language_directory_validation: true,
          metadata_path: "./fastlane/metadata/#{app_name}",
          submission_information: { 
            export_compliance_uses_encryption: false,
            add_id_info_uses_idfa: false 
          }
        )
        
        successful_apps << app_name
        UI.success("âœ… #{app_name} ë¹Œë“œ ë° App Store ì œì¶œ ì™„ë£Œ!")
        
      rescue => error
        failed_apps << app_name
        UI.error("âŒ #{app_name} ë¹Œë“œ/ì œì¶œ ì‹¤íŒ¨: #{error.message}")
        UI.message("ë‹¤ìŒ ì•±ìœ¼ë¡œ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤...")
      end
    end
    
    # ê²°ê³¼ ìš”ì•½
    UI.header("ğŸ“Š App Store ì œì¶œ ê²°ê³¼ ìš”ì•½")
    
    if successful_apps.any?
      UI.success("ğŸ‰ ì „ì²´ ê³¼ì • ì„±ê³µ: #{successful_apps.join(', ')}")
      UI.message("ğŸ’¡ App Store Connectì—ì„œ ì‹¬ì‚¬ ìƒíƒœë¥¼ í™•ì¸í•˜ì„¸ìš”.")
    end
    
    if failed_apps.any?
      UI.error("âŒ ë¹Œë“œ/ì œì¶œ ì‹¤íŒ¨: #{failed_apps.join(', ')}")
    end
    
    if failed_apps.empty?
      UI.success("ëª¨ë“  ì•± App Store ì œì¶œ ì™„ë£Œ! ğŸš€")
      UI.message("ğŸ“± App Store Connectì—ì„œ ì‹¬ì‚¬ ì§„í–‰ ìƒí™©ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.")
    else
      UI.message("ì œì¶œ ì™„ë£Œ: #{successful_apps.length}/#{selected_apps.length} ì„±ê³µ")
    end
  end


  


  desc "Generate screenshots and upload App Store info (combined)"
  lane :full_upload do
    app_names = APPS.keys
    UI.message("ì „ì²´ í”„ë¡œì„¸ìŠ¤ë¥¼ ì‹¤í–‰í•  ì•±ì„ ì„ íƒí•˜ì„¸ìš”:")
    app_names.each_with_index { |name, i| UI.message("#{i+1}. #{name}") }
    
    choices_input = UI.input("ë²ˆí˜¸ ì„ íƒ (ì—¬ëŸ¬ê°œëŠ” ì½¤ë§ˆë¡œ êµ¬ë¶„, ì˜ˆ: 1,3,5): ")
    choices = choices_input.split(',').map(&:strip).map(&:to_i)
    
    # ì…ë ¥ê°’ ê²€ì¦
    invalid_choices = choices.reject { |choice| (1..app_names.length).include?(choice) }
    unless invalid_choices.empty?
      UI.error("ì˜ëª»ëœ ì„ íƒì…ë‹ˆë‹¤: #{invalid_choices.join(', ')}")
      next
    end
    
    selected_apps = choices.map { |choice| app_names[choice-1] }
    UI.success("ì„ íƒëœ ì•±ë“¤: #{selected_apps.join(', ')}")
    
    UI.header("ğŸš€ ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì‹œì‘")
    UI.message("1ï¸âƒ£ ìŠ¤í¬ë¦°ìƒ· ìƒì„± â†’ 2ï¸âƒ£ App Store ì—…ë¡œë“œ")
    
    # ë‹¨ê³„ 1: ìŠ¤í¬ë¦°ìƒ· ìƒì„±
    UI.header("ğŸ¯ 1ë‹¨ê³„: ìŠ¤í¬ë¦°ìƒ· ìƒì„±")
    screenshot_failed_apps = []
    
    selected_apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{selected_apps.length}: #{app_name} ìŠ¤í¬ë¦°ìƒ· ìƒì„± ì¤‘...")
      
      begin
        # ìŠ¤í¬ë¦°ìƒ· ìƒì„± ë¡œì§
        UI.message("ğŸ¨ #{app_name} ì•±ìŠ¤í† ì–´ í”„ë¦¬ë·° ì´ë¯¸ì§€ ìƒì„± ì¤‘...")
        
        # í˜„ì¬ ë””ë ‰í† ë¦¬ ì €ì¥
        original_dir = Dir.pwd
        UI.message("ğŸ“ í˜„ì¬ ë””ë ‰í† ë¦¬: #{original_dir}")
        
        # ì ˆëŒ€ ê²½ë¡œë¡œ xmakes ë””ë ‰í† ë¦¬ ì°¾ê¸°
        xmakes_dir = File.expand_path("../xmakes", original_dir)
        UI.message("ğŸ“ xmakes ë””ë ‰í† ë¦¬: #{xmakes_dir}")
        
        unless Dir.exist?(xmakes_dir)
          UI.error("xmakes í´ë”ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{xmakes_dir}")
          screenshot_failed_apps << app_name
          next
        end
        
        # Python ê°€ìƒí™˜ê²½ í™•ì¸
        venv_python = File.join(xmakes_dir, "venv", "bin", "python")
        unless File.exist?(venv_python)
          UI.message("âš ï¸  ê°€ìƒí™˜ê²½ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê°€ìƒí™˜ê²½ì„ ë¨¼ì € ì„¤ì •í•˜ì„¸ìš”.")
          UI.message("cd xmakes && python3 setup_venv.py")
          screenshot_failed_apps << app_name
          next
        end
        
        # appstore í”„ë¦¬ë·° ìƒì„± ì‹¤í–‰
        Dir.chdir(File.join(xmakes_dir, "appstore")) do
          UI.message("ğŸ“ ì‘ì—… ë””ë ‰í† ë¦¬ ë³€ê²½: #{Dir.pwd}")
          
          # ê¸°ì¡´ output í´ë” ì •ë¦¬
          output_dir = "output"
          sh("rm -rf #{output_dir}") if Dir.exist?(output_dir)
          
          # í”„ë¦¬ë·° ìƒì„± ì‹¤í–‰
          sh("#{venv_python} run_appstore_preview.py")
          
          # ìƒì„±ëœ ì´ë¯¸ì§€ë¥¼ fastlane/screenshots í´ë”ë¡œ ë³µì‚¬
          UI.message("ğŸ“ #{app_name} ìŠ¤í¬ë¦°ìƒ·ì„ fastlane/screenshots í´ë”ë¡œ ë³µì‚¬ ì¤‘...")
          
          # í˜„ì¬ëŠ” plots ì•±ë§Œ ì§€ì›
          app_name_lower = app_name.downcase
          if app_name_lower == "plots"
            source_dir = File.join("output", "plots")
          else
            UI.message("âš ï¸  í˜„ì¬ #{app_name}ì€ ì§€ì›ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤. Plots ì•±ë§Œ ì§€ì›ë©ë‹ˆë‹¤.")
            screenshot_failed_apps << app_name
            next
          end
          
          # ì ˆëŒ€ ê²½ë¡œë¡œ screenshots í´ë” ì„¤ì •
          screenshots_base_dir = File.join(original_dir, "screenshots")
          UI.message("ğŸ“ ëŒ€ìƒ ìŠ¤í¬ë¦°ìƒ· í´ë”: #{screenshots_base_dir}")
          
          unless Dir.exist?(source_dir)
            UI.error("ìƒì„±ëœ ìŠ¤í¬ë¦°ìƒ·ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤: #{source_dir}")
            screenshot_failed_apps << app_name
            next
          end
          
          # ê¸°ì¡´ ì•± ìŠ¤í¬ë¦°ìƒ· í´ë” ì‚­ì œ
          target_app_dir = File.join(screenshots_base_dir, app_name)
          if Dir.exist?(target_app_dir)
            UI.message("ğŸ—‘ï¸  ê¸°ì¡´ #{app_name} ìŠ¤í¬ë¦°ìƒ· í´ë” ì‚­ì œ ì¤‘...")
            sh("rm -rf '#{target_app_dir}'")
          end
          
          # ê° ë””ë°”ì´ìŠ¤ íƒ€ì…ë³„ë¡œ ë³µì‚¬
          ["iphone", "ipad"].each do |device_type|
            device_source = File.join(source_dir, device_type)
            next unless Dir.exist?(device_source)
            
            # ì–¸ì–´ë³„ í´ë” ìˆœíšŒ
            Dir.glob(File.join(device_source, "*")).each do |lang_dir|
              next unless File.directory?(lang_dir)
              
              lang_code = File.basename(lang_dir)
              
              # ëŒ€ìƒ í´ë” ì„¤ì •
              target_lang_dir = File.join(target_app_dir, lang_code)
              
              # ê¸°ì¡´ ìŠ¤í¬ë¦°ìƒ· í´ë”ê°€ ì—†ìœ¼ë©´ ìƒì„±
              unless Dir.exist?(target_lang_dir)
                UI.message("ğŸ“ ë””ë ‰í† ë¦¬ ìƒì„±: #{target_lang_dir}")
                sh("mkdir -p '#{target_lang_dir}'")
              end
              
              # ìŠ¤í¬ë¦°ìƒ· íŒŒì¼ ë³µì‚¬ (jpg, png ëª¨ë‘ ì§€ì›)
              screenshot_files = Dir.glob(File.join(lang_dir, "*.{jpg,png,jpeg}"))
              if screenshot_files.any?
                screenshot_files.each do |screenshot_file|
                  filename = File.basename(screenshot_file)
                  target_file = File.join(target_lang_dir, filename)
                  
                  # íŒŒì¼ ë³µì‚¬
                  sh("cp '#{screenshot_file}' '#{target_file}'")
                  UI.message("ğŸ“¸ ë³µì‚¬ ì™„ë£Œ: #{filename} â†’ #{app_name}/#{lang_code}/")
                end
              else
                UI.message("âš ï¸  #{lang_code} í´ë”ì— ìŠ¤í¬ë¦°ìƒ·ì´ ì—†ìŠµë‹ˆë‹¤.")
              end
            end
          end
        end
        
        UI.success("âœ… #{app_name} ìŠ¤í¬ë¦°ìƒ· ìƒì„± ë° ë³µì‚¬ ì™„ë£Œ!")
        
      rescue => error
        screenshot_failed_apps << app_name
        UI.error("âŒ #{app_name} ìŠ¤í¬ë¦°ìƒ· ìƒì„± ì‹¤íŒ¨: #{error.message}")
      end
    end
    
    # ë‹¨ê³„ 2: App Store ì—…ë¡œë“œ
    UI.header("ğŸ¯ 2ë‹¨ê³„: App Store ì—…ë¡œë“œ")
    
    # 1ë‹¨ê³„: ë²„ì „ ì •ë³´ ìë™ ì„¤ì •
    UI.header("ğŸ“ 2-1: ë²„ì „ ì •ë³´ ìë™ ì„¤ì •")
    app_info = {}
    
    selected_apps.each do |app_name|
      plist_path = "Apps/#{app_name}/Resources/Info.plist"
      
      # plist íŒŒì¼ ê²½ë¡œ ì°¾ê¸°
      if !File.exist?(plist_path)
        alternative_paths = [
          "../Apps/#{app_name}/Resources/Info.plist",
          "#{app_name}/Resources/Info.plist",
          "../#{app_name}/Resources/Info.plist"
        ]
        
        alternative_paths.each do |alt_path|
          if File.exist?(alt_path)
            plist_path = File.expand_path(alt_path)
            break
          end
        end
      end
      
      if File.exist?(plist_path)
        current_version = get_info_plist_value(path: plist_path, key: "CFBundleShortVersionString")
        current_build = get_info_plist_value(path: plist_path, key: "CFBundleVersion")
        
        # ìë™ ì„¤ì •: ë²„ì „ì€ í˜„ì¬ê°’ ìœ ì§€, ë¹Œë“œëŠ” íƒ€ì„ìŠ¤íƒ¬í”„ë¡œ ìë™ ì„¤ì •
        version = current_version
        build = Time.now.strftime("%Y%m%d%H%M%S")
        
        UI.message("#{app_name} ì„¤ì • - ë²„ì „: #{version}, ë¹Œë“œ: #{build} (ì´ì „: #{current_build})")
        
        app_info[app_name] = {
          plist_path: plist_path,
          version: version,
          build: build,
          current_version: current_version,
          current_build: current_build
        }
      else
        UI.error("#{app_name}ì˜ Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!")
        app_info[app_name] = nil
      end
    end
    
    # 2ë‹¨ê³„: ë©”íƒ€ë°ì´í„° ë° ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ
    UI.header("ğŸ“ 2-2: ë©”íƒ€ë°ì´í„° ë° ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ")
    failed_apps = []
    successful_apps = []
    
    selected_apps.each_with_index do |app_name, index|
      UI.header("ğŸ“± #{index + 1}/#{selected_apps.length}: #{app_name} ì—…ë¡œë“œ ì¤‘...")
      
      info = app_info[app_name]
      unless info
        UI.error("âŒ #{app_name}: Info.plist íŒŒì¼ì„ ì°¾ì„ ìˆ˜ ì—†ì–´ ê±´ë„ˆëœë‹ˆë‹¤.")
        failed_apps << app_name
        next
      end
      
      bundle_id = APPS[app_name]
      
      # ìŠ¤í¬ë¦°ìƒ· í´ë” ë° ì‹¤ì œ ìŠ¤í¬ë¦°ìƒ· íŒŒì¼ ì¡´ì¬ í™•ì¸
      screenshots_path = "./screenshots/#{app_name}"
      has_screenshots = false
      screenshot_count = 0
      
      # ì§€ì›ë˜ëŠ” ì–¸ì–´ ì½”ë“œ (Fastlane ê³µì‹ ë¬¸ì„œ ê¸°ì¤€)
      supported_languages = %w[
        ar-SA ca cs da de-DE el en-AU en-CA en-GB en-US es-ES es-MX fi fr-CA fr-FR 
        he hi hr hu id it ja ko ms nl-NL no pl pt-BR pt-PT ro ru sk sv th tr uk vi zh-Hans zh-Hant
      ]
      
      if Dir.exist?(screenshots_path)
        # ì‹¤ì œ ìŠ¤í¬ë¦°ìƒ· íŒŒì¼ ê°œìˆ˜ í™•ì¸ (jpg, png íŒŒì¼)
        screenshot_files = Dir.glob("#{screenshots_path}/**/*.{jpg,png,jpeg}")
        screenshot_count = screenshot_files.length
        has_screenshots = screenshot_count > 0
        
        if has_screenshots
          UI.message("ğŸ“¸ #{app_name} ìŠ¤í¬ë¦°ìƒ· íŒŒì¼ ë°œê²¬: #{screenshot_count}ê°œ")
          
          # ì–¸ì–´ë³„ ìŠ¤í¬ë¦°ìƒ· í´ë” ê²€ì¦
          lang_dirs = Dir.glob("#{screenshots_path}/*/").map { |dir| File.basename(dir) }
          valid_langs = lang_dirs.select { |lang| supported_languages.include?(lang) }
          invalid_langs = lang_dirs - valid_langs
          
          if valid_langs.any?
            UI.message("âœ… ìœ íš¨í•œ ì–¸ì–´ í´ë”: #{valid_langs.join(', ')}")
          end
          
          if invalid_langs.any?
            UI.message("âš ï¸  ì•Œ ìˆ˜ ì—†ëŠ” ì–¸ì–´ í´ë” (ê³„ì† ì§„í–‰): #{invalid_langs.join(', ')}")
          end
        else
          UI.message("ğŸ“ #{app_name} ìŠ¤í¬ë¦°ìƒ· í´ë”ëŠ” ìˆì§€ë§Œ ì´ë¯¸ì§€ íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤.")
        end
      else
        UI.message("ğŸ“ #{app_name} ìŠ¤í¬ë¦°ìƒ· í´ë”ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
      end
      
      begin
        # ë¹Œë“œ ë²ˆí˜¸ ì—…ë°ì´íŠ¸
        if info[:build] != info[:current_build]
          UI.message("ğŸ”¢ #{app_name} ë¹Œë“œ ë²ˆí˜¸ ì—…ë°ì´íŠ¸: #{info[:current_build]} â†’ #{info[:build]}")
          set_info_plist_value(path: info[:plist_path], key: "CFBundleVersion", value: info[:build])
        end
        
        # ë²„ì „ ì—…ë°ì´íŠ¸ (í•„ìš”í•œ ê²½ìš°)
        if info[:version] != info[:current_version]
          UI.message("ğŸ”¢ #{app_name} ë²„ì „ ì—…ë°ì´íŠ¸: #{info[:current_version]} â†’ #{info[:version]}")
          set_info_plist_value(path: info[:plist_path], key: "CFBundleShortVersionString", value: info[:version])
        end
        
        # ë©”íƒ€ë°ì´í„° í´ë” ì¡´ì¬ í™•ì¸
        metadata_folder = "./metadata/#{app_name}"
        unless Dir.exist?(metadata_folder)
          UI.error("âŒ #{app_name} ë©”íƒ€ë°ì´í„° í´ë”ê°€ ì¡´ì¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤: #{metadata_folder}")
          failed_apps << app_name
          next
        end
        
        # ë©”íƒ€ë°ì´í„° ë° ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ
        if has_screenshots
          UI.message("ğŸ“ #{app_name} ë©”íƒ€ë°ì´í„° ë° ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ ì¤‘...")
        else
          UI.message("ğŸ“ #{app_name} ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œ ì¤‘ (ìŠ¤í¬ë¦°ìƒ· ì—†ìŒ)...")
        end
        
        # FastLane í‘œì¤€ ë°©ì‹ìœ¼ë¡œ ì—…ë¡œë“œ
        UI.message("ğŸ” ì•± ID: #{bundle_id}")
        UI.message("ğŸ” ë©”íƒ€ë°ì´í„° ê²½ë¡œ: ./metadata/#{app_name}")
        UI.message("ğŸ” ìŠ¤í¬ë¦°ìƒ· ê²½ë¡œ: #{has_screenshots ? "./screenshots/#{app_name}" : 'ì—†ìŒ'}")
        
        # ìŠ¤í¬ë¦°ìƒ· ê´€ë ¨ ì˜µì…˜ ì„¤ì •
        upload_options = {
          app_identifier: bundle_id,
          skip_binary_upload: true,
          skip_screenshots: !has_screenshots,
          force: true, # HTML ë¯¸ë¦¬ë³´ê¸° ê±´ë„ˆë›°ê¸°
          metadata_path: "./metadata/#{app_name}",
          screenshots_path: "./fastlane/screenshots/#{app_name}/",
          app_version: info[:version],
          run_precheck_before_submit: false,
          # ì–¸ì–´ ë””ë ‰í† ë¦¬ ê²€ì¦ ë¬´ì‹œ (ì˜ëª»ëœ ì–¸ì–´ ì½”ë“œê°€ ìˆì–´ë„ ê³„ì† ì§„í–‰)
          ignore_language_directory_validation: true,
          # ì¸ì•±êµ¬ë§¤ ì‚¬ì „ê²€ì‚¬ í¬í•¨
          precheck_include_in_app_purchases: true,
          # ì‚¬ì „ê²€ì‚¬ ê¸°ë³¸ ê·œì¹™ ë ˆë²¨
          precheck_default_rule_level: :warn
        }
        
        # ìŠ¤í¬ë¦°ìƒ·ì´ ìˆëŠ” ê²½ìš°ì—ë§Œ ìŠ¤í¬ë¦°ìƒ· ê´€ë ¨ ì˜µì…˜ ì¶”ê°€
        if has_screenshots
          upload_options[:screenshots_path] = "./fastlane/screenshots/#{app_name}/"
          # ìŠ¤í¬ë¦°ìƒ·ì´ ì‹¤ì œë¡œ ìˆì„ ë•Œë§Œ overwrite_screenshots ì‚¬ìš©
          upload_options[:overwrite_screenshots] = true
          # ìŠ¤í¬ë¦°ìƒ· ì²˜ë¦¬ íƒ€ì„ì•„ì›ƒ ì„¤ì • (ê¸°ë³¸ 1ì‹œê°„)
          upload_options[:screenshot_processing_timeout] = 3600
          UI.message("ğŸ”„ ê¸°ì¡´ ìŠ¤í¬ë¦°ìƒ·ì„ ìƒˆ ìŠ¤í¬ë¦°ìƒ·ìœ¼ë¡œ êµì²´í•©ë‹ˆë‹¤.")
        else
          UI.message("âš ï¸  ìŠ¤í¬ë¦°ìƒ·ì´ ì—†ì–´ overwrite_screenshots ì˜µì…˜ì„ ì‚¬ìš©í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.")
        end
        
        # App Store Connect ì—…ë¡œë“œ ì‹¤í–‰
        UI.message("ğŸš€ App Store Connectì— ì—…ë¡œë“œ ì¤‘...")
        upload_to_app_store(upload_options)
        
        successful_apps << app_name
        UI.success("âœ… #{app_name} ì—…ë¡œë“œ ì™„ë£Œ!")
        
        # ì„±ê³µ í›„ ìš”ì•½ ì •ë³´
        if has_screenshots
          UI.message("ğŸ“¸ #{screenshot_count}ê°œ ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œë¨")
        end
        UI.message("ğŸ“ ë©”íƒ€ë°ì´í„° ì—…ë¡œë“œë¨")
        UI.message("ğŸ’¡ App Store Connectì—ì„œ ë³€ê²½ì‚¬í•­ì„ í™•ì¸í•˜ì„¸ìš”")
        
      rescue => error
        failed_apps << app_name
        UI.error("âŒ #{app_name} ì—…ë¡œë“œ ì‹¤íŒ¨: #{error.message}")
        
        # ì—ëŸ¬ íƒ€ì…ë³„ ê°€ì´ë“œ ì œê³µ
        error_message = error.message.downcase
        if error_message.include?("invalid") && error_message.include?("language")
          UI.message("ğŸ’¡ ì–¸ì–´ í´ë” ì´ë¦„ì„ í™•ì¸í•˜ì„¸ìš”. ì§€ì›ë˜ëŠ” í˜•ì‹: ko, en-US, ja, zh-Hans ë“±")
        elsif error_message.include?("screenshot")
          UI.message("ğŸ’¡ ìŠ¤í¬ë¦°ìƒ· íŒŒì¼ í˜•ì‹ê³¼ í¬ê¸°ë¥¼ í™•ì¸í•˜ì„¸ìš”. PNG ê¶Œì¥")
        elsif error_message.include?("metadata")
          UI.message("ğŸ’¡ ë©”íƒ€ë°ì´í„° í´ë” êµ¬ì¡°ë¥¼ í™•ì¸í•˜ì„¸ìš”: ./metadata/#{app_name}/")
        elsif error_message.include?("timeout")
          UI.message("ğŸ’¡ ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•˜ê±°ë‚˜ ë‚˜ì¤‘ì— ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”")
        end
        
        UI.message("ë‹¤ìŒ ì•±ìœ¼ë¡œ ê³„ì† ì§„í–‰í•©ë‹ˆë‹¤...")
      end
    end
    
    # ê²°ê³¼ ìš”ì•½
    UI.header("ğŸ“Š ì „ì²´ í”„ë¡œì„¸ìŠ¤ ê²°ê³¼ ìš”ì•½")
    
    # ìŠ¤í¬ë¦°ìƒ· ìƒì„± ê²°ê³¼
    successful_screenshot_apps = selected_apps - screenshot_failed_apps
    if successful_screenshot_apps.any?
      UI.success("âœ… ìŠ¤í¬ë¦°ìƒ· ìƒì„± ì„±ê³µ: #{successful_screenshot_apps.join(', ')}")
    end
    
    if screenshot_failed_apps.any?
      UI.error("âŒ ìŠ¤í¬ë¦°ìƒ· ìƒì„± ì‹¤íŒ¨: #{screenshot_failed_apps.join(', ')}")
    end
    
    # ì—…ë¡œë“œ ê²°ê³¼
    if successful_apps.any?
      UI.success("ğŸ‰ ì—…ë¡œë“œ ì„±ê³µ: #{successful_apps.join(', ')}")
      UI.message("ğŸ’¡ App Store Connectì—ì„œ ë³€ê²½ì‚¬í•­ì„ í™•ì¸í•˜ì„¸ìš”.")
      UI.message("ğŸ”— https://appstoreconnect.apple.com/")
    end
    
    if failed_apps.any?
      UI.error("âŒ ì—…ë¡œë“œ ì‹¤íŒ¨: #{failed_apps.join(', ')}")
      UI.message("ğŸ’¡ ì—ëŸ¬ ë©”ì‹œì§€ë¥¼ í™•ì¸í•˜ê³  ë¬¸ì œë¥¼ í•´ê²°í•œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.")
    end
    
    UI.header("ğŸ‰ ì „ì²´ í”„ë¡œì„¸ìŠ¤ ì™„ë£Œ!")
    UI.message("ğŸ“± App Store Connectì—ì„œ ë³€ê²½ì‚¬í•­ì„ í™•ì¸í•˜ì„¸ìš”.")
    UI.message("ğŸ”— https://appstoreconnect.apple.com/")
  end

  desc "Reset certificates"
  lane :reset do
    ["development", "appstore"].each do |type|
      match_nuke(type: type, app_identifier: APPS.values)
      match(type: type, app_identifier: APPS.values, readonly: false, username: "mooyoung2309@gmail.com")
    end
    UI.success("Certificates reset! ğŸ”")
  end
  


end