# Refactored Fastfile
# frozen_string_literal: true

default_platform(:ios)

# --- Configuration ---

# App identifiers
APPS = {
  "Toffs" => "com.tamsadan.toolinder",
  "Plots" => "com.annapo.plotfolio",
  "Retros" => "com.annapo.kpt",
  "Multis" => "com.annapo.taskfolio",
  "Capts" => "com.folio.world.mulling.app.ios",
  "FewCuts" => "com.annapo.fewcuts",
}.freeze

# Tuist workspace name, located in the project root
WORKSPACE_NAME = "FewsWorkspace"
WORKSPACE_PATH = "../#{WORKSPACE_NAME}.xcworkspace".freeze

# --- Lanes ---

platform :ios do
  # This is executed before any lane
  before_all do
    setup_environment
  end

  # --- Main Public Lanes ---

  desc "TestFlight에 앱을 빌드하고 업로드합니다."
  lane :upload do
    deploy(
      is_testflight: true,
      title: "TestFlight 업로드"
    )
  end

  desc "App Store에 리뷰를 위해 앱을 빌드하고 제출합니다."
  lane :submit_to_appstore do
    deploy(
      submit_for_review: true,
      title: "App Store 제출"
    )
  end

  desc "스크린샷 생성부터 메타데이터 업로드까지 전체 과정을 실행합니다."
  lane :full_upload do
    UI.header("🚀 전체 프로세스 시작: 스크린샷 생성 및 App Store 업로드")
    
    selected_apps = select_apps(all_apps: APPS.keys)
    break if selected_apps.empty?

    screenshot_results = generate_screenshots_for_apps(apps: selected_apps)
    upload_results = upload_app_details(apps: selected_apps)

    print_full_upload_summary(screenshot_results: screenshot_results, upload_results: upload_results)
  end

  desc "인증서를 초기화합니다."
  lane :reset do
    ["development", "appstore"].each do |type|
      match_nuke(type: type, app_identifier: APPS.values)
      match(type: type, app_identifier: APPS.values, readonly: false, username: "mooyoung2309@gmail.com")
    end
    UI.success("✅ 인증서 초기화 완료! 🔐")
  end

  # --- Private Helper Lanes ---

  private_lane :deploy do |options|
    UI.header("🚀 #{options[:title]} 프로세스 시작")
    
    selected_apps = select_apps(all_apps: APPS.keys)
    break if selected_apps.empty?

    app_versions = prompt_for_version_info(apps: selected_apps)
    break unless UI.confirm("위 정보로 빌드를 시작하시겠습니까?")

    results = { successful: [], failed: [], build_only_success: [] }
    selected_apps.each_with_index do |app_name, index|
      UI.header("📱 #{index + 1}/#{selected_apps.length}: #{app_name} 처리 중...")
      
      version_info = app_versions[app_name]
      unless version_info
        UI.error("❌ #{app_name}: Info.plist 파일을 찾을 수 없어 건너뜁니다.")
        results[:failed] << app_name
        next
      end

      begin
        ipa_path = build_and_archive_app(app_name: app_name, version_info: version_info)

        if options[:is_testflight]
          upload_to_testflight(ipa: ipa_path, skip_waiting_for_build_processing: true)
          UI.success("✅ #{app_name} 빌드 및 TestFlight 업로드 완료")
          
          begin
            upload_metadata(app_name: app_name)
            results[:successful] << app_name
          rescue => e
            UI.error("❌ #{app_name} 메타데이터 업로드 실패: #{e.message}")
            results[:build_only_success] << app_name
          end
        else
          submit_for_review(app_name: app_name, ipa_path: ipa_path)
          results[:successful] << app_name
        end
      rescue => e
        results[:failed] << app_name
        UI.error("❌ #{app_name} 처리 실패: #{e.message}")
      end
    end

    print_deploy_summary(results: results, title: options[:title])
  end

  private_lane :generate do
    UI.message("🔧 Tuist 프로젝트를 생성합니다...")
    Dir.chdir("..") do # Move to project root to run tuist
      sh("tuist install", log: false, error_callback: ->(result) {
        UI.message("Tuist install 실행 중 오류가 있었지만 계속 진행합니다.")
      })
      sh("tuist generate --no-open")
    end
    UI.success("✅ Tuist 프로젝트 생성 완료!")
  end

  # --- Helper Methods ---

  def setup_environment
    api_key_json = JSON.parse(File.read("api_key.json"))
    app_store_connect_api_key(
      key_id: api_key_json["key_id"],
      issuer_id: api_key_json["issuer_id"], 
      key_content: api_key_json["key"]
    )
    
    ENV["FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT"] = "120"
    ENV["FASTLANE_XCODEBUILD_SETTINGS_RETRIES"] = "2"
    ENV["ENABLE_USER_SCRIPT_SANDBOXING"] = "NO"
    ENV["FASTLANE_ENABLE_BETA_DELIVER_SYNC_SCREENSHOTS"] = "true"
  end

  def select_apps(all_apps:)
    UI.message("앱을 선택하세요:")
    all_apps.each_with_index { |name, i| UI.message("#{i+1}. #{name}") }
    
    choices_input = UI.input("번호 선택 (여러개는 콤마로 구분, 예: 1,3,5): ")
    choices = choices_input.split(',').map(&:strip).map(&:to_i)
    
    invalid_choices = choices.reject { |c| (1..all_apps.length).include?(c) }
    unless invalid_choices.empty?
      UI.error("잘못된 선택입니다: #{invalid_choices.join(', ')}")
      return []
    end
    
    selected_apps = choices.map { |c| all_apps[c-1] }.uniq
    UI.success("선택된 앱: #{selected_apps.join(', ')}")
    selected_apps
  end

  def find_plist_path(app_name)
    path = "../Apps/#{app_name}/Resources/Info.plist"
    File.exist?(path) ? File.expand_path(path) : nil
  end

  def prompt_for_version_info(apps:)
    UI.header("📝 버전 정보 입력")
    app_versions = {}
    
    apps.each do |app_name|
      plist_path = find_plist_path(app_name)
      if plist_path
        current_version = get_info_plist_value(path: plist_path, key: "CFBundleShortVersionString")
        UI.message("#{app_name} 현재 버전: #{current_version}")
        
        version_input = UI.input("#{app_name}의 새 버전 (현재값 유지하려면 엔터): ")
        version = version_input.empty? ? current_version : version_input
        build = Time.now.strftime("%Y%m%d%H%M%S")
        
        app_versions[app_name] = { plist_path: plist_path, version: version, build: build }
      else
        UI.error("#{app_name}의 Info.plist 파일을 찾을 수 없습니다!")
        app_versions[app_name] = nil
      end
    end
    
    UI.header("📋 입력된 버전 정보 확인")
    app_versions.each do |app, info|
      info ? UI.message("#{app}: 버전 #{info[:version]}, 빌드 #{info[:build]}") : UI.error("#{app}: 설정 불가")
    end
    
    app_versions
  end

  def build_and_archive_app(app_name:, version_info:)
    UI.message("🔨 #{app_name} 빌드 및 아카이브 중...")
    
    set_info_plist_value(path: version_info[:plist_path], key: "CFBundleShortVersionString", value: version_info[:version])
    set_info_plist_value(path: version_info[:plist_path], key: "CFBundleVersion", value: version_info[:build])
    
    clear_derived_data
    generate
    
    output_path = "./build"
    sh("mkdir -p #{output_path}")
    
    gym(
      workspace: WORKSPACE_PATH,
      scheme: app_name,
      configuration: "Release",
      export_method: "app-store",
      clean: false,
      destination: "generic/platform=iOS",
      skip_package_dependencies_resolution: true,
      disable_package_automatic_updates: true,
      output_directory: output_path,
      output_name: app_name,
      xcargs: "-allowProvisioningUpdates -skipMacroValidation",
      export_options: {
        method: "app-store",
        compileBitcode: false,
        uploadBitcode: false,
        uploadSymbols: true,
        manageAppVersionAndBuildNumber: false
      }
    )
    
    UI.success("✅ #{app_name} 빌드 완료")
    "#{output_path}/#{app_name}.ipa"
  end

  def upload_metadata(app_name:)
    UI.message("📝 #{app_name} 메타데이터 업로드 중...")
    upload_to_app_store(
      app_identifier: APPS[app_name],
      skip_binary_upload: true,
      skip_screenshots: true,
      force: true,
      ignore_language_directory_validation: true,
      metadata_path: "./metadata/#{app_name}"
    )
    UI.success("✅ #{app_name} 메타데이터 업로드 완료")
  end

  def submit_for_review(app_name:, ipa_path:)
    UI.message("🚀 #{app_name} App Store 제출 중...")
    upload_to_app_store(
      ipa: ipa_path,
      app_identifier: APPS[app_name],
      submit_for_review: true,
      automatic_release: true,
      force: true,
      skip_screenshots: true,
      run_precheck_before_submit: true,
      ignore_language_directory_validation: true,
      metadata_path: "./metadata/#{app_name}",
      submission_information: { 
        export_compliance_uses_encryption: false,
        add_id_info_uses_idfa: false 
      }
    )
    UI.success("✅ #{app_name} App Store 제출 완료")
  end

  def print_deploy_summary(results:, title:)
    UI.header("📊 #{title} 결과 요약")
    
    UI.success("🎉 전체 과정 성공: #{results[:successful].join(', ')}") if results[:successful].any?
    UI.message("⚠️ 빌드 성공, 메타데이터 실패: #{results[:build_only_success].join(', ')}") if results[:build_only_success].any?
    UI.error("❌ 빌드/업로드 실패: #{results[:failed].join(', ')}") if results[:failed].any?
    
    total = results[:successful].length + results[:build_only_success].length + results[:failed].length
    total_success = results[:successful].length + results[:build_only_success].length
    
    if results[:failed].empty?
      UI.success("모든 앱 처리 완료! 🚀")
    else
      UI.message("빌드 완료: #{total_success}/#{total} 성공")
    end
  end

  # --- `full_upload` Helper Methods ---

  def generate_screenshots_for_apps(apps:)
    UI.header("🎯 1단계: 스크린샷 생성")
    results = { successful: [], failed: [] }
    
    apps.each_with_index do |app_name, index|
      UI.header("📱 #{index + 1}/#{apps.length}: #{app_name} 스크린샷 생성 중...")
      begin
        # Currently only "Plots" is supported, as in the original script
        if app_name.downcase != "plots"
          UI.message("⚠️  현재 #{app_name}은(는) 스크린샷 생성을 지원하지 않습니다. 건너뜁니다.")
          next
        end

        run_screenshot_generator(app_name)
        results[:successful] << app_name
        UI.success("✅ #{app_name} 스크린샷 생성 및 복사 완료!")
      rescue => e
        results[:failed] << { app: app_name, reason: e.message }
        UI.error("❌ #{app_name} 스크린샷 생성 실패: #{e.message}")
      end
    end
    results
  end

  def run_screenshot_generator(app_name)
    xmakes_dir = "../xmakes"
    raise "xmakes 폴더를 찾을 수 없습니다: #{xmakes_dir}" unless Dir.exist?(xmakes_dir)

    venv_python_relative_to_appstore = "../venv/bin/python"
    xmakes_appstore_dir = File.join(xmakes_dir, "appstore")
    
    unless File.exist?(File.join(xmakes_appstore_dir, venv_python_relative_to_appstore))
      raise "Python 가상환경을 찾을 수 없습니다. `cd ../xmakes && python3 setup_venv.py`를 실행하세요."
    end

    Dir.chdir(xmakes_appstore_dir) do
      sh("rm -rf output") if Dir.exist?("output")
      sh("#{venv_python_relative_to_appstore} run_appstore_preview.py")
      copy_screenshots(app_name: app_name)
    end
  end

  def copy_screenshots(app_name:)
    UI.message("📁 스크린샷 복사 중...")
    source_dir = "output/plots" # Hardcoded "plots" as in original
    raise "생성된 스크린샷 폴더를 찾을 수 없습니다: #{source_dir}" unless Dir.exist?(source_dir)

    # Get the absolute path to the project root
    project_root = File.expand_path("..")
    UI.message("DEBUG: project_root: #{project_root}")
    
    target_app_dir = File.join(project_root, "screenshots", app_name)
    UI.message("DEBUG: target_app_dir: #{target_app_dir}")
    sh("rm -rf '#{target_app_dir}'") if Dir.exist?(target_app_dir)
    sh("mkdir -p '#{target_app_dir}'")

    # Get all locales from metadata directory to ensure all screenshot directories are created
    metadata_locales = Dir.glob(File.join(project_root, "metadata", app_name, "*")).select { |f| File.directory?(f) }.map { |f| File.basename(f) }

    # Get all locales from generated screenshots
    generated_locales = Dir.glob("#{source_dir}/*/*").select { |f| File.directory?(f) }.map { |f| File.basename(f) }

    # Create directories for all locales (metadata + generated screenshots)
    all_locales = (metadata_locales + generated_locales).uniq
    all_locales.each do |locale|
      target_lang_dir = File.join(target_app_dir, locale)
      UI.message("DEBUG: target_lang_dir for #{locale}: #{target_lang_dir}")
      sh("mkdir -p '#{target_lang_dir}'")
      UI.message("📁 #{locale} 스크린샷 디렉토리 생성.")
    end

    # Copy generated screenshots into their respective language folders
    Dir.glob("#{source_dir}/*/*").each do |lang_dir|
      next unless File.directory?(lang_dir)
      lang_code = File.basename(lang_dir)
      target_lang_dir = File.join(target_app_dir, lang_code)
      
      # Check if there are any PNG files to copy
      png_files = Dir.glob("#{lang_dir}/*.png")
      if png_files.empty?
        UI.message("⚠️  #{lang_code}: 복사할 PNG 스크린샷이 없습니다.")
        next
      end
      
      cp_command = "cp '#{lang_dir}'/*.png '#{target_lang_dir}/'"
      UI.message("DEBUG: cp_command: #{cp_command}")
      sh(cp_command)
      UI.message("📸 #{lang_code} 스크린샷 복사 완료.")
    end
  end

  def upload_app_details(apps:)
    UI.header("🎯 2단계: 메타데이터 및 스크린샷 업로드")
    results = { successful: [], failed: [] }

    apps.each_with_index do |app_name, index|
      UI.header("📱 #{index + 1}/#{apps.length}: #{app_name} 업로드 중...")
      begin
        plist_path = find_plist_path(app_name)
        raise "Info.plist 파일을 찾을 수 없습니다." unless plist_path

        version = get_info_plist_value(path: plist_path, key: "CFBundleShortVersionString")
        build = Time.now.strftime("%Y%m%d%H%M%S")
        set_info_plist_value(path: plist_path, key: "CFBundleVersion", value: build)
        UI.message("🔢 #{app_name} 버전: #{version}, 새 빌드: #{build}")

        screenshots_path = "./screenshots/#{app_name}/"
        has_screenshots = Dir.exist?(screenshots_path) && !Dir.glob("#{screenshots_path}/**/*.{jpg,png,jpeg}").empty?

        # Use sync_screenshots instead of overwrite_screenshots to avoid deletion verification issues
        upload_to_app_store(
          app_identifier: APPS[app_name],
          app_version: version,
          skip_binary_upload: true,
          force: true,
          metadata_path: "./metadata/#{app_name}",
          screenshots_path: "./screenshots/#{app_name}/",
          skip_screenshots: false,
          sync_screenshots: true,
          ignore_language_directory_validation: true,
          precheck_include_in_app_purchases: false,
          run_precheck_before_submit: false
        )
        
        results[:successful] << app_name
        UI.success("✅ #{app_name} 업로드 완료!")
      rescue => e
        if e.message.include?("Failed verification of all screenshots deleted")
          UI.important("⚠️ #{app_name} 스크린샷 삭제 확인 실패: #{e.message}")
          UI.important("이 문제는 Fastlane의 알려진 동작이며, 업로드는 계속됩니다.")
          UI.important("실제 업로드는 성공할 수 있으므로 App Store Connect에서 확인하세요.")
          results[:successful] << app_name # Consider it successful for the purpose of the overall lane
        elsif e.message.include?("screenshot") && e.message.include?("delete")
          UI.important("⚠️ #{app_name} 스크린샷 관련 오류: #{e.message}")
          UI.important("이 문제는 Fastlane의 알려진 동작이며, 업로드는 계속됩니다.")
          results[:successful] << app_name
        else
          results[:failed] << { app: app_name, reason: e.message }
          UI.error("❌ #{app_name} 업로드 실패: #{e.message}")
        end
      end
    end
    results
  end

  def print_full_upload_summary(screenshot_results:, upload_results:)
    UI.header("📊 전체 프로세스 결과 요약")

    UI.message("
--- 스크린샷 생성 결과 ---")
    UI.success("✅ 성공: #{screenshot_results[:successful].join(', ')}") if screenshot_results[:successful].any?
    UI.error("❌ 실패: #{screenshot_results[:failed].map { |f| f[:app] }.join(', ')}") if screenshot_results[:failed].any?

    UI.message("
--- App Store 업로드 결과 ---")
    UI.success("✅ 성공: #{upload_results[:successful].join(', ')}") if upload_results[:successful].any?
    UI.error("❌ 실패: #{upload_results[:failed].map { |f| f[:app] }.join(', ')}") if upload_results[:failed].any?

    UI.message("
🎉 전체 프로세스 완료!")
    UI.message("💡 App Store Connect에서 변경사항을 확인하세요: https://appstoreconnect.apple.com/")
  end
end